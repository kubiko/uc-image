#!/bin/bash

# This program is free software: you can redistribute it and/or modify it
# under the terms of the the GNU General Public License version 3, as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranties of
# MERCHANTABILITY, SATISFACTORY QUALITY or FITNESS FOR A PARTICULAR
# PURPOSE.  See the applicable version of the GNU General Public
# License for more details.
#.
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Copyright (C) 2020 Canonical, Ltd.

# this can be used to validate if there is newer version available
SCRIPT_VERSION=2.2

unset BUILDER_CONFIG
declare -A BUILDER_CONFIG

# fill in default values
BUILDER_CONFIG["OUTPUT_DIR"]="$(readlink -f uc-db-build)"
BUILDER_CONFIG["BUILDER_DEBUG"]="${DB_BUILDER_DEBUG}"
BUILDER_CONFIG["SEARCH_PATH"]="${DB_BUILDER_PATH}"
# delete all logs
rm -rf $(dirname $(mktemp -u -t uc-db-builder-XXXX))/uc-db-builder-* 2> /dev/null
BUILDER_CONFIG["TMP_LOG_FILE"]="$(mktemp -t uc-db-builder-XXXX)"
[ -z "${BUILDER_CONFIG["BUILDER_DEBUG"]}" ] && BUILDER_CONFIG["BUILDER_DEBUG"]=1
[ -n "${DB_BUILDER_WORK_DIR}" ] && BUILDER_CONFIG["WORK_DIR"]=${DB_BUILDER_WORK_DIR}
[ -n "${DB_BUILDER_OUTPUT_DIR}" ] && BUILDER_CONFIG["OUTPUT_DIR"]=$(readlink -f ${DB_BUILDER_OUTPUT_DIR})

# boot assets candidate directories in gadget snap
BOOT_ASSETS_CANDIDATES="blobs boot-assets"
unset BOOT_ASSETS

SNAP_REQUIRED_INTERFACES="home mount-observe network-observe ssh-public-keys"

# print help
print_help () {
    echo "Builder for UbuntuCore for images supporting fastboot like flash tool"
    echo ""
    echo "positional arguments:"
    echo "  model_assertion       Path to the model assertion file. This argument must"
    echo "                        be given unless the state machine is being resumed, in"
    echo "                        which case it cannot be given."
    echo ""
    echo "optional arguments:"
    echo "  -h, --help            show this help message and exit"
    echo "  --snap SNAP           Install an extra snap."
    echo "                        This is passed through to 'snap prepare-image'. The snap argument can include"
    echo "                        additional information about the track|risk channel/branch"
    echo "                        with the following syntax: <snap>=<track|channel/branch>"
    echo "                        examples: --snap go=1.14|stable"
    echo "                                  --snap avahi.snap"
    echo "  -c CHANNEL, --channel CHANNEL"
    echo "                        The snap channel to use, one of stable/candidate/beta/edge"
    echo "                        stable channel is assumed if no channel is defined"
    echo "                        example: -c edge"
    echo "  -d, --debug           print debug"
    echo "  -dd                   print verbose debugs"
    echo ""
    echo "Common options:"
    echo "!!! Not all options are available when building Ubuntu Core 20 image!!!"
    echo "  --netplan-config NETPLAN-CONFIG-FILE"
    echo "                        Network config for netplan, should not be combined with --network-config"
    echo "  --cloud-init USER-DATA-FILE"
    echo "                        cloud-config data to be copied to the image"
    echo "  --network-config NETWORK-CONFIG-FILE"
    echo "                        Network config for cloud init"
    echo "  --disable-console-conf"
    echo "                        disable first boot console configuration"
    echo "  --auto-import-assertion  ASSERTION FILE"
    echo "                        Auto import assertion file to be included in root of main writable partiton."
    echo "                        This assertion is imported once system is fully seeded"
    echo "                        Passed file does not need to have correct file name, it will be renamed"
    echo "  --hooks-directory DIRECTORY"
    echo "                        Path of directory in which scripts for build-time hooks will be located."
    echo "                        see ubuntu-image help for more information"
    echo "  -O DIRECTORY, --output-dir DIRECTORY"
    echo "                        The directory in which to put generated disk image"
    echo "                        files."
    echo "  -w DIRECTORY, --workdir DIRECTORY"
    echo "                        The working directory in which to download and unpack"
    echo "                        all the source/snap files for the image. This directory can"
    echo "                        exist or not, and it is not removed after this program"
    echo "                        exits. If not given, a temporary working directory is"
    echo "                        used instead under /tmp"
    echo "  -o, --overlay"
    echo "                        Directory to overlay on top of rootfs"
    echo "                        !!! this option cannot be guaranteed !!!"
    echo "                            use only on your own risk!"
    echo "                            intended for device enablement phase"
    echo " --full-size            Writable partition is build to full size to occupy rest of the available space on storage"
    echo "                        This is usefull when writable partition should not be resized at first boot"
    echo " --keep-raw             Keep raw writable image as well as sparse image used by fastboot"
    echo "                        fastboot typically expects sparse image for ext4 partitions, to minimise size of the"
    echo "                        image to be flashed."
    echo "                        Raw images are needed when QFIL or qdl flash tools are used"
    echo " --build-raw            Build raw image, instead of sparse one"
    echo " --journald-storage-persistent"
    echo "                        Configure system to use persistent storage for journald logs instead of default volatile settings"
    echo " --disable-ssh-server"
    echo "                        Disable system's ssh server from very beginning of the first boot"
    echo " --seed-root-ssh-authorized-keys"
    echo "                        populate root's authorized_keys (/root/.ssh/authorized_keys) with passed"
    echo "                        public key(s)"
    echo "                        example: --seed-root-ssh-authorized-keys <key 1> [key 2]"
    echo "                        to enable early boot loggin, combine with use of --enable-early-getty"
    echo " --enable-early-getty"
    echo "                        Forcefull disabling of console conf and early enablement of getty"
    echo "                        !!! Use this only for boot debugging, not suitable for production images"
    echo "                        This option as consequence disables console-conf"
    echo " --set-hostname HOSTNAME"
    echo "                        Set initial hostname to be used at first boot"
    echo "                        !!! This feature is not guarteed as it's using image overlay"
    echo " --build-recovery-seed"
    echo "                        Only supported for uc18 with fde"
    echo "                        Build only seed partition image which can be used for"
    echo "                        - update of factory image on device"
    echo "                        - device reflash through factory reset process"
    echo "                        created seed.img image is not sparse image, so it cannot be used with fastboot"
    echo "                        seed image also contains other partition to be reflashed during factory reset"
    echo " -v|--version"
    echo "                        print version of the script"
    echo ""
    echo "Builder supports default settings passed through environment variables"
    echo "Supported env variables:"
    echo "    DB_BUILDER_PATH:       Colon separated search paths to use to search for passed file parameters"
    echo "                           if not provided with absolute or relative path."
    echo "                           First successful find is used."
    echo "                           This search path is used for model assertions, snaps, network configs, auto-import-assertion, netplan-config"
    echo "    DB_BUILDER_DEBUG:      Default log level"
    echo "                           0 - no logs, 3 - detailed logs. Default level is '1'"
    echo "    DB_BUILDER_WORK_DIR:   Default work directory to be used"
    echo "                           If not defined or passed as param, tmp directory is created"
    echo "    DB_BUILDER_OUTPUT_DIR: Default output directory"
    echo "                           If not defined or passed as param, 'uc-db-build' directory will be created in current directory"
}

# normalize version
normalize_version () {
   echo "$@" | awk -F. '{ printf("%d%03d%03d%03d\n", $1,$2,$3,$4); }'
}

# provision macOS
provision_macOS_system () {
  if [ -n "$(uname -a | grep Darwin)" ]; then
    ## building on macOS, check if dependencies are installed

    # first check brew cellars, required cellars: e2fsprogs, simg2img, squashfs, dosfstools
    if [ ! -f "$(which brew)" ]; then
      echo "This system has no brew installed. There is no way to install dependencies required for image building"
      echo "see https://brew.sh"
      exit 0
    fi
    echo -e "\nChecking system dependencies"
    # brew list is very slow, so check for files instead
    declare -A UC_BUILD_DEPENDENCIES
    UC_BUILD_DEPENDENCIES["e2fsprogs"]="mkfs.ext4"
    UC_BUILD_DEPENDENCIES["simg2img"]="img2simg"
    UC_BUILD_DEPENDENCIES["squashfs"]="mksquashfs"
    UC_BUILD_DEPENDENCIES["dosfstools"]="mkfs.vfat"
    UC_BUILD_DEPENDENCIES["fakeroot"]="fakeroot"
    UC_BUILD_DEPENDENCIES["mtools"]="mcopy"
    UC_BUILD_DEPENDENCIES["yq"]="yq"

    for pckg in "${!UC_BUILD_DEPENDENCIES[@]}"
    do
      if [ ! -f "$(which  ${UC_BUILD_DEPENDENCIES[${pckg}]})" ]; then
        echo -e "installing brew cellar ${pckg}"
        # brew install ${pckg}
      fi
    done

    # check if we have snap client binary
    if [ ! ${HOME}/bin/snap ]; then
      echo "Downloadig snap client...."
      mkdir -p ${HOME}/bin
      wget https://people.canonical.com/~okubik/snap.macOS -o ${HOME}/bin/snap
      chmod +x ${HOME}/bin/snap
      echo "Downloaded version of snap client:"
      snap version
    fi

    BUILDER_CONFIG["FAKEROOT"]="fakeroot "

    # update script if there is never version
    local people_url="https://people.canonical.com/~okubik/build-uc-image"
    local latest_version=$(curl -s ${people_url} | grep SCRIPT_VERSION= | head -n1 | awk -F '=' '{print $2}')
    if [ $(normalize_version ${SCRIPT_VERSION}) -ge $(normalize_version ${latest_version}) ]; then
      echo -e "Script version is up to date\n"
    else
      echo -e "!!! Script is outdated, download new one from ${people_url} !!!\n"
      exit 0
    fi
  fi
}

# check snaps interfaces are connected before progressing
check_snap_environment () {
  # are we even running in snap confinement
  if [ -z "$(env | grep SNAP_INSTANCE_NAME)" ]; then
    echo "Detected non snap environment execution (running unconfined)"
    return
  fi
  # ensure we have all the interfaces connected
  local missing_connections=""
  for plug in ${SNAP_REQUIRED_INTERFACES}
  do
    if ! snapctl is-connected ${plug}; then
      missing_connections="${missing_connections}${plug} "
    fi
  done

  if [ -n "${missing_connections}" ]; then
    echo "Snap does not have connected plugs required for its function, please connected them"
    echo "By running:"
    for p in ${missing_connections}
    do
      echo -e "\t$ snap connect ${SNAP_INSTANCE_NAME}:${p}"
    done
    exit 0
  fi

  # check we are not running as root
  if [ "$USER" =  "root" ]; then
    echo "Please do not run with sudo, no need for this"
    exit 0
  fi
}

# print debug log
print_debug () {
  local level=${1}
  shift
  [ "${BUILDER_CONFIG["BUILDER_DEBUG"]}" -ge "${level}" ] && echo -e "$@"
  # if work dir does not exist yet, log to tmp log file
  if [ -e "${BUILDER_CONFIG["TMP_LOG_FILE"]}" ]; then
    echo -e "$@" >> ${BUILDER_CONFIG["TMP_LOG_FILE"]}
  else
    echo -e "$@" >> ${BUILDER_CONFIG["WORK_DIR"]}/builder.log
  fi
}

# print builder config if debug log
print_builder_config () {
  if [ "${BUILDER_CONFIG["BUILDER_DEBUG"]}" -ge "2" ]; then
    print_debug 1 "Builder configuration:"
    for i in "${!BUILDER_CONFIG[@]}"; do
      print_debug 1 "\t$i = ${BUILDER_CONFIG[$i]}"
    done
    # print empty line
    echo ""
  fi
}

# prepare work directory
prepare_work_directory () {
  # first clean previus tmp directories
  rm -rf $(dirname $(mktemp -u -d -t uc-db-workdir-XXXXX))/uc-db-workdir-*
  rm -rf ${SNAP_USER_COMMON}/uc-db-builder-* 2> /dev/null
  # if work directory is not defined, use tmp one
  if [ -z "${BUILDER_CONFIG["WORK_DIR"]}" ]; then
    # work dir not defined create tmp one
    BUILDER_CONFIG["WORK_DIR"]=$(mktemp -d -t uc-db-workdir-XXXX)
    mkdir -p ${BUILDER_CONFIG["WORK_DIR"]}
    print_debug 2 "Creating temp work directory: ${BUILDER_CONFIG["WORK_DIR"]}"
  else
    # make sure dir exists
    if [ -d ${BUILDER_CONFIG["WORK_DIR"]} ]; then
        print_debug 2 "Cleaning old build directory [${BUILDER_CONFIG["WORK_DIR"]}]"
        rm -rf ${BUILDER_CONFIG["WORK_DIR"]}
    fi
    mkdir -p ${BUILDER_CONFIG["WORK_DIR"]}
  fi
}

# dtermine if we are building for UC20
determine_uc2x() {
  print_debug 3 "determine_uc2x"
  if [ -n "$(grep 'base: core20' ${BUILDER_CONFIG["MODEL_ASSERTION"]} 2> /dev/null)" ]; then
    print_debug 2 "Target Ubuntu Core 20+ detected"
    BUILDER_CONFIG["UC20"]="true"
  else
    print_debug 2 "Target PRE Ubuntu Core 20 detected"
    BUILDER_CONFIG["UC20"]="false"
  fi
}

# determine bootloader type
determine_bootloader () {
  print_debug 3 "determine_bootloader"
  # determine boot assets dir
  for ba in ${BOOT_ASSETS_CANDIDATES}
  do
    if [ -d ${BUILDER_CONFIG["WORK_DIR"]}/gadget/${ba} ]; then
      BOOT_ASSETS=${ba}
      continue
    fi
  done
  # UC20 behaves differently from UC16/18
  if [ "${BUILDER_CONFIG["UC20"]}" = "true" ]; then
    BUILDER_CONFIG["IMAGE_ROOT"]=${BUILDER_CONFIG["WORK_DIR"]}/system-seed
  else
    BUILDER_CONFIG["IMAGE_ROOT"]=${BUILDER_CONFIG["WORK_DIR"]}/image
    mkdir -p ${BUILDER_CONFIG["WORK_DIR"]}/root/system-data/
  fi

  print_debug 3 "BUILDER_CONFIG["IMAGE_ROOT"]=${BUILDER_CONFIG["IMAGE_ROOT"]}"
  # we can have u-boot, lk, or special case of lk amboot(Ambarella amboot)
  if [  -d ${BUILDER_CONFIG["IMAGE_ROOT"]}/boot/uboot ]; then
    BUILDER_CONFIG["BOOTLOADER"]="uboot"
    mv ${BUILDER_CONFIG["IMAGE_ROOT"]}/boot/uboot ${BUILDER_CONFIG["WORK_DIR"]}/system-boot
    cp -r ${BUILDER_CONFIG["WORK_DIR"]}/gadget/${BOOT_ASSETS} ${BUILDER_CONFIG["WORK_DIR"]}/system-boot/
  elif [ -d ${BUILDER_CONFIG["IMAGE_ROOT"]}/boot/lk ]; then
    BUILDER_CONFIG["BOOTLOADER"]="lk"
    mv ${BUILDER_CONFIG["IMAGE_ROOT"]}/boot/lk ${BUILDER_CONFIG["WORK_DIR"]}/lk
    # check if this is amboot special case
    if [ -d ${BUILDER_CONFIG["WORK_DIR"]}/gadget/${BOOT_ASSETS}/amboot ]; then
      # set some configuratoon for amboot case
      BUILDER_CONFIG["BUILD_RAW"]="true"
      BUILDER_CONFIG["AMBOOT"]="true"
    fi
  else
    print_debug 0 "Unrecognised bootloader, exiting"
    exit 0
  fi

  if [ "${BUILDER_CONFIG["UC20"]}" != "true" ]; then
    mv ${BUILDER_CONFIG["IMAGE_ROOT"]}/* ${BUILDER_CONFIG["WORK_DIR"]}/root/system-data/
    # set new image root
    BUILDER_CONFIG["IMAGE_ROOT"]=${BUILDER_CONFIG["WORK_DIR"]}/root
  fi
  print_debug 1 "\nDetected bootloader: ${BUILDER_CONFIG["BOOTLOADER"]}"
}

# validate passed parameter is file
# if passed string is not file with relative/absolute path
# BUILDER_CONFIG["SEARCH_PATH"] variable is used as search path to look for the file
# first hit is used
# function returns absolute path to the file if file is validated or none
validate_file () {
    local file=${1}
    if [ -n "${file}" ]; then
        if [ ! -e ${file} ]; then
            # only use when we actually have search path
            if [ -n "${BUILDER_CONFIG["SEARCH_PATH"]}" ]; then
                IFS=":"
                for p in ${BUILDER_CONFIG["SEARCH_PATH"]}
                do
                    if [ -e ${p}/${file} ]; then
                        echo $(readlink -f ${p}/${file})
                        return
                    fi
                done
            fi
        else
            echo $(readlink -f ${file})
        fi
    fi
}

# validate passed snap
# passed snap can be either snap name from store or local file
# function return either snap name or absolute path to snap file
validate_snap () {
    local s="${1}"
    if [ "${s: -5}" = ".snap" ]; then
        # check if local snap file exists
        echo "$(validate_file ${s})"
    else
        # store snap
        echo "${s}"
    fi
}

# normalise passed size to kilo bytes
# passed size can be in Kilo(K|k), Mega(M|m), Giga(G\g) bytes
# if not specified value is assumed in bytes
normalise_size_to_kb () {
  local size=${1}
  case $size in
     (0)  size="0" ;;
     (*G | *g) size=$(expr $(echo $size | sed -e 's/G//g' -e 's/g//g') \* 1024 \* 1024) ;;
     (*M | *m) size=$(expr $(echo $size | sed -e 's/M//g' -e 's/m//g') \* 1024) ;;
     (*K | *k) size=$(echo $size | sed -e 's/K//g' -e 's/k//g') ;;
     (*) size=$(expr $size / 1024) ;;
  esac
  echo ${size}
}

# seed cloud init user_data
# if no cloud init user data is passed do nothing
seed_cloud_init_user_data () {
  print_debug 5 "seed_cloud_init_user_data(${BUILDER_CONFIG["CLOUD_INIT_USER_DATA"]})"
  if [ -n "${BUILDER_CONFIG["CLOUD_INIT_USER_DATA"]}" ]; then
    print_debug 1 "\nUsing passed cloud init user data configuration: [${BUILDER_CONFIG["CLOUD_INIT_USER_DATA"]}]"
    mkdir -p ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/var/lib/cloud/seed/nocloud-net
    cp ${BUILDER_CONFIG["CLOUD_INIT_USER_DATA"]} ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/var/lib/cloud/seed/nocloud-net/user-data
    echo "instance-id: nocloud-static" > ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/var/lib/cloud/seed/nocloud-net/meta-data
  fi
}

# seed cloud init network config
# if no cloud init network config is passed do nothing
seed_cloud_init_net_config () {
  print_debug 5 "seed_cloud_init_net_config(${BUILDER_CONFIG["CLOUD_INIT_NETWORK_CONFIG"]})"
  if [ -n "${BUILDER_CONFIG["CLOUD_INIT_NETWORK_CONFIG"]}" ]; then
    print_debug 1 "\nUsing passed cloud init network configuration: [${BUILDER_CONFIG["CLOUD_INIT_NETWORK_CONFIG"]}]"
    mkdir -p ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/var/lib/cloud/seed/nocloud-net
    cp ${BUILDER_CONFIG["CLOUD_INIT_NETWORK_CONFIG"]} ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/var/lib/cloud/seed/nocloud-net/network-config
    echo "instance-id: nocloud-static" > ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/var/lib/cloud/seed/nocloud-net/meta-data
  fi
}

# seed netplan network config if provided
# if no netplan config is passed do nothing
seed_netplan_config () {
  print_debug 5 "seed_netplan_config(${BUILDER_CONFIG["NETPLAN_CONF"]})"
  if [ -n "${BUILDER_CONFIG["NETPLAN_CONF"]}" ]; then
    print_debug 1 "\nUsing passed netplan configuration: [${BUILDER_CONFIG["NETPLAN_CONF"]}]"
    mkdir -p ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/etc/netplan
    cp ${BUILDER_CONFIG["NETPLAN_CONF"]} ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/etc/netplan/00-snapd-config.yaml
  fi
}

# seed passed assertion as auto import assertion
# one assertion can be passed
# if no assertion is passed do nothing
seed_auto_import_assertion () {
  print_debug 5 "seed_auto_import_assertion(${BUILDER_CONFIG["ASSERTION_IMPORT"]})"
  if [ -n "${BUILDER_CONFIG["ASSERTION_IMPORT"]}" ]; then
    print_debug 1 "\nImporting passed assertion file: [${BUILDER_CONFIG["ASSERTION_IMPORT"]}]"
    cp ${BUILDER_CONFIG["ASSERTION_IMPORT"]} ${BUILDER_CONFIG["IMAGE_ROOT"]}/auto-import.assert
  fi
}

# invoke custom hooks if provided
# if no hook directory is passed do nothing
invoke_hooks () {
  print_debug 5 "invoke_hooks"
  if [ -n "${HOOK_DIR}" ]; then
    print_debug 1 "\nInvoking hooks"
    export UBUNTU_IMAGE_HOOK_ROOTFS="$(realpath ${BUILDER_CONFIG["IMAGE_ROOT"]})"
    if [ -f ${HOOK_DIR}/post-populate-rootfs ]; then
      UBUNTU_IMAGE_HOOK_ROOTFS="$(realpath ${BUILDER_CONFIG["IMAGE_ROOT"]})" ${HOOK_DIR}/post-populate-rootfs
    fi
    if [ -d ${HOOK_DIR}/post-populate-rootfs.d ]; then
      UBUNTU_IMAGE_HOOK_ROOTFS="$(realpath ${BUILDER_CONFIG["IMAGE_ROOT"]})" find ${HOOK_DIR}/post-populate-rootfs.d -type f -executable -exec sh -c {} \;
    fi
  fi
}

# disable console conf if requested
# if disable console conf is not requested, do nothing
disable_console_conf () {
  print_debug 5 "disable_console_conf(${BUILDER_CONFIG["DISABLE_CONSOLE_CONF"]})"
  if [ "true" = "${BUILDER_CONFIG["DISABLE_CONSOLE_CONF"]}" ]; then
    print_debug 1 "\nDisabling console conf"
    mkdir -p ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/var/lib/console-conf
    touch ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/var/lib/console-conf/complete
  fi
}

# enable early getty if requested
# if no early getty is not requested, do nothing
enable_early_getty () {
  print_debug 5 "enable_early_getty(${BUILDER_CONFIG["ENABLE_EARLY_GETTY"]})"
  if [ "true" = "${BUILDER_CONFIG["ENABLE_EARLY_GETTY"]}" ]; then
    print_debug 1 "\nEnabling early getty"
    mkdir -p ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/etc/systemd/system/serial-getty@.service.d/
    mkdir -p ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/etc/systemd/system/getty@.service.d/
    ln -s /dev/null ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/etc/systemd/system/console-conf@.service
    ln -s /dev/null ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/etc/systemd/system/serial-console-conf@.service
    echo -e "[Service]\nExecStartPre=" > ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/etc/systemd/system/serial-getty@.service.d/z-console-conf-serial.conf
    echo -e "[Service]\nExecStartPre=" > ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/etc/systemd/system/getty@.service.d/z-console-conf.conf
  fi
}

# check if device should be configured with persistent journal storage
# if no persistent journal is passed do nothing
enable_persisten_journal () {
  print_debug 5 "enable_persisten_journal(${BUILDER_CONFIG["JOURNAL_STORAGE_PERSISTENT"]})"
  if [ "${BUILDER_CONFIG["JOURNAL_STORAGE_PERSISTENT"]}" = "true" ]; then
    print_debug 1 "\nSwitching journald to use persistent storage"
    mkdir -p ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/var/log/journal
  fi
}

# check if system's ssh server should be disabled
# if disable ssh server is not requested do nothing
disable_ssh_server () {
  print_debug 5 "disable_ssh_server(${BUILDER_CONFIG["DISABLE_SSH_SERVER"]})"
  if [ "${BUILDER_CONFIG["DISABLE_SSH_SERVER"]}" = "true" ]; then
    print_debug 1 "\nDisabling system ssh server"
    mkdir -p ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/etc/ssh
    touch ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/etc/ssh/sshd_not_to_be_run
  fi
}

# check if we should set default hostname
# if no hostname is passed do nothing
seed_hostname () {
  print_debug 5 "seed_hostname(${BUILDER_CONFIG["HOSTNAME"]})"
  if [ -n "${BUILDER_CONFIG["HOSTNAME"]}" ]; then
    print_debug 1 "\nSetting initial hostname to [ ${BUILDER_CONFIG["HOSTNAME"]} ]"
    mkdir -p ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/etc/
    echo ${BUILDER_CONFIG["HOSTNAME"]} > ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/etc/hostname
  fi
}

# check if we should seed authorized ssh kyes for root user
# if no root authorised keys are passed do nothing
seed_root_authorized_keys () {
  print_debug 5 "seed_root_authorized_keys(${SSH_PUB_KEY_FILES})"
  if [ -n "${SSH_PUB_KEY_FILES}" ]; then
    print_debug 1 "\nSeeding root authorized ssh keys [${SSH_PUB_KEY_FILES}]"
    SSH_DIR="${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/root/.ssh"
    mkdir -p ${SSH_DIR}
    chmod 700 ${SSH_DIR}
    AUTHORIZED_KEYS="${SSH_DIR}/authorized_keys"
    for key in ${SSH_PUB_KEY_FILES}
    do
      if [ -f ${key} ]; then
          cat ${key} >> ${AUTHORIZED_KEYS}
      fi
    done
    chmod 600 ${AUTHORIZED_KEYS}
  fi
}

# Apply custom overlay if there are some
# if no custom overlay is passed do nothing
seed_custom_overlay () {
  print_debug 5 "seed_custom_overlay(${BUILDER_CONFIG["CUSTOM_OVERLAY"]})"
  if [ -n "${BUILDER_CONFIG["CUSTOM_OVERLAY"]}" ];then
    print_debug 1 "Applying custom overlay"
    cp -r ${BUILDER_CONFIG["CUSTOM_OVERLAY"]}/* ${BUILDER_CONFIG["IMAGE_ROOT"]}
  fi
}

# create system-boot partition if needed
create_system_boot_partition_image () {
  print_debug 5 "create_system_boot_partition_image()"
  # u-boot bootloader is using dedicated 'system-boot' partition
  if [ "${BUILDER_CONFIG["BOOTLOADER"]}" = "uboot" ]; then
      print_debug 1 "\nCreating system-boot partition"
      dd if=/dev/zero of=${BUILDER_CONFIG["WORK_DIR"]}/system-boot.img bs=1024 count=131072
      ${BUILDER_CONFIG["FAKEROOT"]}mkfs.vfat \
          -s 1 \
          -S 512 \
          -F 32 \
          -n 'system-boot' \
          ${BUILDER_CONFIG["WORK_DIR"]}/system-boot.img 2>&1 | tee -a ${BUILDER_CONFIG["WORK_DIR"]}/builder.log
      mcopy \
          -s \
          -i ${BUILDER_CONFIG["WORK_DIR"]}/system-boot.img \
          ${BUILDER_CONFIG["WORK_DIR"]}/system-boot/* :: 2>&1 | tee -a ${BUILDER_CONFIG["WORK_DIR"]}/builder.log
  fi
}

# create seed partition image
create_seed_partition_image () {
  print_debug 1 "\nCreating seed partition image"
  # copy back up files in root/boot

  local seed_size_human=$(yq r ${gadget_yaml} 'volumes.*.*.(name==seed).size')
  local SEED_SIZE="$(normalise_size_to_kb ${seed_size_human})k"
  print_debug 2 "${BUILDER_CONFIG["FAKEROOT"]}mkfs.ext4 -O -metadata_csum -T default -E root_owner=0:0 -O uninit_bg -L seed -d ${BUILDER_CONFIG["IMAGE_ROOT"]} ${BUILDER_CONFIG["WORK_DIR"]}/seed.raw ${SEED_SIZE}"
  ${BUILDER_CONFIG["FAKEROOT"]}mkfs.ext4 \
      -O \
      -metadata_csum \
      -T default \
      -E root_owner=0:0 \
      -O uninit_bg \
      -L seed \
      -d ${BUILDER_CONFIG["IMAGE_ROOT"]} ${BUILDER_CONFIG["WORK_DIR"]}/seed.raw \
      ${SEED_SIZE} 2>&1 | tee -a ${BUILDER_CONFIG["WORK_DIR"]}/builder.log
  if [ ! -f ${BUILDER_CONFIG["WORK_DIR"]}/seed.raw ]; then
      print_debug 1 "\nImage creation for seed partiton failed, bailing out!!!"
      exit 0
  fi
  # if we are not building recovery seed, convert image to sparse
  if [ ! "${BUILDER_CONFIG["RECOVERY_SEED"]}" = "true" ] \
     || [ ! "${BUILDER_CONFIG["BUILD_RAW"]}" = "true" ]; then
       print_debug 1 "\nCreate sparse image for seed"
       print_debug 2 "img2simg ${BUILDER_CONFIG["WORK_DIR"]}/seed.raw ${BUILDER_CONFIG["OUTPUT_DIR"]}/seed.img"
       img2simg \
         ${BUILDER_CONFIG["WORK_DIR"]}/seed.raw \
         ${BUILDER_CONFIG["OUTPUT_DIR"]}/seed.img 2>&1 | tee -a ${BUILDER_CONFIG["WORK_DIR"]}/builder.log
  fi
}

# create writable partition image
create_writable_partition_image () {
  # root partition is "writable"
  print_debug 1 "\nCreating image for writable"

  if [ "${BUILDER_CONFIG["RECOVERY_SEED"]}" = "true" ]; then
    print_debug 0 "Gadget snap has not defined seed partition!!"
    print_debug 0 "--build-recovery-seed option is not compatible with used gadget snap"
    exit 0
  fi

  if [ "${BUILDER_CONFIG["BUILD_FULL_SIZE"]}" = "true" ]; then
    print_debug 1 "Calculating size required for writable partition"
    #Â db410c storage is: 7818182656 bytes (15269854)
    local ROOT_SIZE="$(sgdisk -p ${BUILDER_CONFIG["WORK_DIR"]}/gadget/${BOOT_ASSETS}/gpt_both0.bin 2>&1 | grep writable | awk '{printf("%.0f",(15269854-$2))}')"
    local ROOT_SIZE="$(sgdisk -p ${BUILDER_CONFIG["WORK_DIR"]}/gadget/${BOOT_ASSETS}/gpt_both0.bin 2>&1 | grep writable | awk '{printf("%.0f",(15269854-$2)*512)}')B"
    local ROOT_SIZE="$(sgdisk -p ${BUILDER_CONFIG["WORK_DIR"]}/gadget/${BOOT_ASSETS}/gpt_both0.bin 2>&1 | grep writable | awk '{printf("%.0f",(15269854-$2)/2)}')K"
    local ROOT_SIZE="$(sgdisk -p ${BUILDER_CONFIG["WORK_DIR"]}/gadget/${BOOT_ASSETS}/gpt_both0.bin 2>&1 | grep writable | awk '{printf("%.0f",(15269854-$2-51200)/2048)}')M"
   # ROOT_SIZE="$(sgdisk -p ${BUILDER_CONFIG["WORK_DIR"]}/gadget/${BOOT_ASSETS}/gpt_both0.bin 2>&1 | grep writable | awk '{printf("%.0f", (15269854-$2)*512)}')"
    print_debug 2 "ROOT_SIZE=${ROOT_SIZE}"
  else
    print_debug 1 "Calculating required size of writable partition image"
    # make root size bigger by what be needed for boot backup
    local root_size=$(find ${BUILDER_CONFIG["IMAGE_ROOT"]} -exec du -s {} + | awk '{total = total + $1}END{printf("%.0fMB",(total / 1024 + 50))}')
    print_debug 4 "root_size=${root_size}"

    if [ "${BUILDER_CONFIG["BOOTLOADER"]}" = "uboot" ]; then
        local system_boot_size="$(du -sh ${BUILDER_CONFIG["WORK_DIR"]}/system-boot | awk '{print $1}')"
        print_debug 2 "Adding size of 'system-boot' to writable image size"
        ROOT_SIZE=$(echo ${root_size} | awk -v sb="${system_boot_size}" '{printf("%.0f",($1+sb))}')M
    elif [ "${BUILDER_CONFIG["BOOTLOADER"]}" = "lk" ]; then
        print_debug 2 "Adding size of 'lk' to writable image size"
        local lk_size="$(du -sh ${BUILDER_CONFIG["WORK_DIR"]}/lk | awk '{print $1}')"
        ROOT_SIZE=$(echo ${root_size} | awk -v sb="${lk_size}" '{printf("%.0f",($1+sb))}')M
        print_debug 2 "ROOT_SIZE=${ROOT_SIZE}"
    fi
  fi
  print_debug 2 "${BUILDER_CONFIG["FAKEROOT"]}mkfs.ext4 -O -metadata_csum -T default -E root_owner=0:0 -O uninit_bg -L writable -d ${BUILDER_CONFIG["IMAGE_ROOT"]} ${BUILDER_CONFIG["WORK_DIR"]}/writable.raw ${ROOT_SIZE}"
  ${BUILDER_CONFIG["FAKEROOT"]}mkfs.ext4 \
      -O \
      -metadata_csum \
      -T default \
      -E root_owner=0:0 \
      -O uninit_bg \
      -L writable \
      -d ${BUILDER_CONFIG["IMAGE_ROOT"]} \
      ${BUILDER_CONFIG["WORK_DIR"]}/writable.raw \
      ${ROOT_SIZE} 2>&1 | tee -a ${BUILDER_CONFIG["WORK_DIR"]}/builder.log
  if [ ! -f ${BUILDER_CONFIG["WORK_DIR"]}/writable.raw ]; then
      print_debug 1 "\nImage creation for writable partiton failed, bailing out!!!"
      exit 0
  fi
  if [ "${BUILDER_CONFIG["BUILD_RAW"]}" != "true" ]; then
      print_debug 1 "\nCreate sparse image for writable"
      print_debug 2 "img2simg ${BUILDER_CONFIG["WORK_DIR"]}/writable.raw ${BUILDER_CONFIG["OUTPUT_DIR"]}/writable.img"
      img2simg \
          ${BUILDER_CONFIG["WORK_DIR"]}/writable.raw \
          ${BUILDER_CONFIG["OUTPUT_DIR"]}/writable.img 2>&1 | tee -a ${BUILDER_CONFIG["WORK_DIR"]}/builder.log
  fi
}

# create UC20 seed partition image
create_uc20_seed_partition_image () {
  print_debug 1 "\nCreating UC20 seed partition image"

  # calculate ubuntu-seed part size
  local seed_size_human=$(yq r ${gadget_yaml} 'volumes.*.*.(name==ubuntu-seed).size')
  local SEED_SIZE="$(normalise_size_to_kb ${seed_size_human})k"
  print_debug 2 "${BUILDER_CONFIG["FAKEROOT"]}mkfs.ext4 -O -metadata_csum -T default -E root_owner=0:0 -O uninit_bg -L ubuntu-seed -d ${BUILDER_CONFIG["IMAGE_ROOT"]} ${BUILDER_CONFIG["WORK_DIR"]}/ubuntu-seed.raw ${SEED_SIZE}"
  ${BUILDER_CONFIG["FAKEROOT"]}mkfs.ext4 \
      -O \
      -metadata_csum \
      -T default \
      -E root_owner=0:0 \
      -O uninit_bg \
      -L ubuntu-seed \
      -d ${BUILDER_CONFIG["IMAGE_ROOT"]} ${BUILDER_CONFIG["WORK_DIR"]}/ubuntu-seed.raw \
      ${SEED_SIZE} 2>&1 | tee -a ${BUILDER_CONFIG["WORK_DIR"]}/builder.log
  if [ ! -f ${BUILDER_CONFIG["WORK_DIR"]}/ubuntu-seed.raw ]; then
      print_debug 1 "\nImage creation for ubuntu-seed partiton failed, bailing out!!!"
      exit 0
  fi
  if [ "${BUILDER_CONFIG["BUILD_RAW"]}" != "true" ]; then
      print_debug 1 "\nCreate sparse image for ubuntu-seed"
      print_debug 2 "img2simg ${BUILDER_CONFIG["WORK_DIR"]}/ubuntu-seed.raw ${BUILDER_CONFIG["OUTPUT_DIR"]}/ubuntu-seed.img"
      img2simg \
        ${BUILDER_CONFIG["WORK_DIR"]}/ubuntu-seed.raw \
        ${BUILDER_CONFIG["OUTPUT_DIR"]}/ubuntu-seed.img 2>&1 | tee -a ${BUILDER_CONFIG["WORK_DIR"]}/builder.log
  fi
}

copy_release_files () {
  if [ "${BUILDER_CONFIG["KEEP_RAW"]}" = "true" ] \
    || [ "${BUILDER_CONFIG["BUILD_RAW"]}" = "true" ]; then
        [ -e ${BUILDER_CONFIG["WORK_DIR"]}/writable.raw ] \
          && mv ${BUILDER_CONFIG["WORK_DIR"]}/writable.raw \
                ${BUILDER_CONFIG["OUTPUT_DIR"]}/
        [ -e ${BUILDER_CONFIG["WORK_DIR"]}/seed.raw ] \
          && mv ${BUILDER_CONFIG["WORK_DIR"]}/seed.raw \
                ${BUILDER_CONFIG["OUTPUT_DIR"]}/
  fi

  # copy gadget boot assets files if making normal release
  if [ ! "${BUILDER_CONFIG["RECOVERY_SEED"]}" = "true" ]; then
    cp -r ${BUILDER_CONFIG["WORK_DIR"]}/gadget/${BOOT_ASSETS}/* \
          ${BUILDER_CONFIG["OUTPUT_DIR"]}/
    if [ "${BUILDER_CONFIG["BOOTLOADER"]}" = "uboot" ]; then
      mv ${BUILDER_CONFIG["WORK_DIR"]}/system-boot.img \
        ${BUILDER_CONFIG["OUTPUT_DIR"]}
    elif [ "${BUILDER_CONFIG["BOOTLOADER"]}" = "lk" ]; then
      cp ${BUILDER_CONFIG["WORK_DIR"]}/lk/* \
         ${BUILDER_CONFIG["OUTPUT_DIR"]}/
    fi
  fi
}

run_amba_image_build () {
  # gather files for amba image build first
  cp -r ${BUILDER_CONFIG["WORK_DIR"]}/gadget/blobs/amboot \
        ${BUILDER_CONFIG["WORK_DIR"]}/amba-build
  mkdir -p ${BUILDER_CONFIG["WORK_DIR"]}/amba-build/images
  cp ${BUILDER_CONFIG["WORK_DIR"]}/gadget/blobs/*.bin \
     ${BUILDER_CONFIG["WORK_DIR"]}/amba-build/images

  [ -e ${BUILDER_CONFIG["WORK_DIR"]}/writable.raw ] \
    && mv ${BUILDER_CONFIG["WORK_DIR"]}/writable.raw \
          ${BUILDER_CONFIG["WORK_DIR"]}/amba-build/images/lnx.bin
  [ -e ${BUILDER_CONFIG["WORK_DIR"]}/seed.raw ] \
    && mv ${BUILDER_CONFIG["WORK_DIR"]}/seed.raw \
          ${BUILDER_CONFIG["WORK_DIR"]}/amba-build/images/lnx.bin

  [ -e ${BUILDER_CONFIG["WORK_DIR"]}/ubuntu-seed.raw ] \
    && mv ${BUILDER_CONFIG["WORK_DIR"]}/ubuntu-seed.raw \
          ${BUILDER_CONFIG["WORK_DIR"]}/amba-build/images/ubuntu-seed.img

  # add gpt image and rename it
  [ -e ${BUILDER_CONFIG["WORK_DIR"]}/gadget/blobs/gpt_both0.bin ] \
    && cp ${BUILDER_CONFIG["WORK_DIR"]}/gadget/blobs/gpt_both0.bin \
          ${BUILDER_CONFIG["WORK_DIR"]}/amba-build/images/gpt_both.bin

  if [ "${BUILDER_CONFIG["BOOTLOADER"]}" = "lk" ]; then
    cp ${BUILDER_CONFIG["WORK_DIR"]}/lk/* \
       ${BUILDER_CONFIG["WORK_DIR"]}/amba-build/images/
  fi

  # run amba image builder script, we need to run it in dir
  # as it has some hardcoded paths
  pushd ${BUILDER_CONFIG["WORK_DIR"]}/amba-build
  ${SNAP}/bin/build-amba-images \
     ${BUILDER_CONFIG["WORK_DIR"]}/amba-build \
     ${BUILDER_CONFIG["WORK_DIR"]}/amba-build/images \
     ${BUILDER_CONFIG["OUTPUT_DIR"]}
  popd
}

# generate image manifest
generate_manifest () {
  # create image manifest
  local IMAGE_MANIFEST="${BUILDER_CONFIG["OUTPUT_DIR"]}/ubuntu-core-image.manifest"
  if [ -e ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/var/lib/snapd/seed/assertions/model ]; then
      sed '1,/timestamp/!d' ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/var/lib/snapd/seed/assertions/model > ${IMAGE_MANIFEST}
  fi
  if [ -e ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/var/lib/snapd/seed/seed.yaml ]; then
      sed -e '/snap-id:/d' \
          -e '/contact:/d' \
          -e 's/snaps:/seeded snaps:/g' \
          -e 's/file:.*_\(.*\).snap/revision: \1/' \
          ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/var/lib/snapd/seed/seed.yaml \
        >> ${IMAGE_MANIFEST}
  fi
}

# parse passed parameters
while [ "$1" != "" ]; do
    case $1 in
        -c | --channel)
            BUILDER_CONFIG["CHANNEL"]="--channel ${2}"
            shift
            ;;
        --snap=*)
            EX_SNAP=$(echo ${1} | awk -F= '{print $2}')
            BUILDER_CONFIG["SNAPS"]="${BUILDER_CONFIG["SNAPS"]} --snap=$(validate_snap ${EX_SNAP})"
            ;;
        --snap)
            BUILDER_CONFIG["SNAPS"]="${BUILDER_CONFIG["SNAPS"]} --snap=$(validate_snap ${2})"
            shift
            ;;
        -O | --output-dir)
            BUILDER_CONFIG["OUTPUT_DIR"]="$(readlink -f ${2})"
            if [ -z "${BUILDER_CONFIG["OUTPUT_DIR"]}" ]; then
              print_debug 0 "Passed output directory cannot be created!!"
              exit
            fi
            shift
            ;;
        -w | --workdir)
            BUILDER_CONFIG["WORK_DIR"]="$(readlink -f ${2})"
            shift
            ;;
        --netplan-config)
            f=$(validate_file ${2})
            if [ -n "${f}" ] && [ -f ${f} ]; then
                BUILDER_CONFIG["NETPLAN_CONF"]="${f}"
            else
                print_debug 0 "wrong netplan config file was passed [ ${2} ]"
                exit
            fi
            shift
            ;;
        --cloud-init)
            f=$(validate_file ${2})
            if [ -n "${f}" ] && [ -f ${f} ]; then
                BUILDER_CONFIG["CLOUD_INIT_USER_DATA"]="${f}"
            else
                print_debug 0 "wrong cloud init user data file was passed [ ${2} ]"
                exit
            fi
            shift
            ;;
        --hooks-directory)
            if [ -n "$2" ] && [ -d $2 ];then
                HOOK_DIR="$(readlink -f ${2})"
            else
                print_debug 0 "wrong hooks dir was passed [ ${2} ]"
                exit
            fi
            shift
            ;;
        --network-config)
            f=$(validate_file ${2})
            if [ -n "${f}" ] && [ -f ${f} ]; then
                BUILDER_CONFIG["CLOUD_INIT_NETWORK_CONFIG"]="${f}"
            else
                print_debug 0 "wrong network config for cloud init was passed [ ${2} ]"
                exit
            fi
            shift
            ;;
        --auto-import-assertion)
            f=$(validate_file ${2})
            if [ -n "${f}" ] && [ -f ${f} ]; then
                 BUILDER_CONFIG["ASSERTION_IMPORT"]="${f}"
            else
                 print_debug 0 "wrong assertion file to import was passed [ ${2} ]"
                 exit
            fi
            shift
            ;;
        --disable-console-conf)
            BUILDER_CONFIG["DISABLE_CONSOLE_CONF"]="true"
            ;;
        -o | --overlay)
            if [ -n "${2}" ] && [ -d ${2} ]; then
                BUILDER_CONFIG["CUSTOM_OVERLAY"]="$(readlink -f ${2})"
                print_debug 0 "!!! This function is not guaranteed, use on own risk !!!"
            else
                print_debug 0 "wrong overlay directory passed [ ${2} ]"
                exit
            fi
            shift
            ;;
        --full-size)
            BUILDER_CONFIG["BUILD_FULL_SIZE"]="true"
            ;;
        --help | -h)
            print_help
            exit
            ;;
        --keep-raw)
            BUILDER_CONFIG["KEEP_RAW"]="true"
            ;;
        --build-raw)
            BUILDER_CONFIG["BUILD_RAW"]="true"
            ;;
        --build-recovery-seed)
            BUILDER_CONFIG["RECOVERY_SEED"]="true"
            # copy raw image as output
            BUILDER_CONFIG["KEEP_RAW"]="true"
            ;;
        --journald-storage-persistent)
            BUILDER_CONFIG["JOURNAL_STORAGE_PERSISTENT"]="true"
            ;;
        --disable-ssh-server)
            BUILDER_CONFIG["DISABLE_SSH_SERVER"]="true"
            ;;
        --seed-root-ssh-authorized-keys)
            # multiple keys can be passed, but at least one
            while
                f=$(validate_file ${2})
                if [ -n "${f}" ] && [ -f ${f} ]; then
                    SSH_PUB_KEY_FILES="${f} ${SSH_PUB_KEY_FILES}"
                else
                    break
                fi
                shift
            do [ -z "${f}" ]; done
            # we need at least one pub key file
            if [ -z "${SSH_PUB_KEY_FILES}" ]; then
                print_debug 0 "wrong ssh public key file was passed [ ${SSH_PUB_KEY_FILES} ]"
                exit
            fi
            ;;
        --enable-early-getty)
            BUILDER_CONFIG["ENABLE_EARLY_GETTY"]="true"
            ;;
        --set-hostname)
            if [ -n "${2}" ]; then
               BUILDER_CONFIG["HOSTNAME"]="${2}"
            else
               print_debug 0 "Missing hostname parameter"
            fi
            shift
            ;;
        -d | --debug)
            BUILDER_CONFIG["BUILDER_DEBUG"]=3
            ;;
        -dd)
            BUILDER_CONFIG["BUILDER_DEBUG"]=5
            ;;
        -v | --version)
            echo -e "version: ${SCRIPT_VERSION}"
            exit 0
            ;;
        *)
            # check if this is model assertion
            ma=$(validate_file ${1})
            if [ -n "${ma}" ]; then
                BUILDER_CONFIG["MODEL_ASSERTION"]=${ma}
            else
                print_debug 0 "Unknown parameter '$1'"
                print_help
                exit
            fi
            ;;
    esac
    shift
done

# make sure system is ready
provision_macOS_system

# check we have all the permissions
check_snap_environment

# first create or clean work directory
prepare_work_directory

print_builder_config

# run snap prepare image with all known parameters
print_debug 1 "Running: snap prepare-image ${BUILDER_CONFIG["CHANNEL"]} ${BUILDER_CONFIG["SNAPS"]} ${BUILDER_CONFIG["MODEL_ASSERTION"]} ${BUILDER_CONFIG["WORK_DIR"]}"
if ! snap prepare-image ${BUILDER_CONFIG["CHANNEL"]} ${BUILDER_CONFIG["SNAPS"]} ${BUILDER_CONFIG["MODEL_ASSERTION"]} ${BUILDER_CONFIG["WORK_DIR"]} 2>&1 | tee -a ${BUILDER_CONFIG["TMP_LOG_FILE"]}; then
  print_debug 0 "snap prepare-image failed, bailing out"
  exit
fi
print_debug 2 "snap prepare-image completed"

# merge logs
mv ${BUILDER_CONFIG["TMP_LOG_FILE"]} ${BUILDER_CONFIG["WORK_DIR"]}/builder.log
# determine bootloader
determine_uc2x
determine_bootloader

# for UC20 there are no additional image modifications supported yet
if [ "${BUILDER_CONFIG["UC20"]}" != "true" ]; then
# updated seeded image per passed configurations
    # seed cloud init user_data if provided
    seed_cloud_init_user_data
    # seed cloud init network config if provided
    seed_cloud_init_net_config
    # seed netplan network config if provided
    seed_netplan_config
    # seed auto import assertion if provided
    seed_auto_import_assertion
    # invoke custom hooks if provided
    invoke_hooks
    # disable console conf if requested
    disable_console_conf
    # enable early getty if requested
    enable_early_getty
    # check if device should be configured with persistent journal storage
    enable_persisten_journal
    # check if system's ssh server should be disabled
    disable_ssh_server
    # check if we should set default hostname
    seed_hostname
    # check if we should seed authorized ssh kyes for root user
    seed_root_authorized_keys
    # Apply custom overlay if there are some
    seed_custom_overlay
else
    if [ -n "${BUILDER_CONFIG["CLOUD_INIT_USER_DATA"]}" ] \
       || [ -n "${BUILDER_CONFIG["CLOUD_INIT_NETWORK_CONFIG"]}" ] \
       || [ -n "${BUILDER_CONFIG["NETPLAN_CONF"]}" ] \
       || [ -n "${BUILDER_CONFIG["ASSERTION_IMPORT"]}" ] \
       || [ -n "${HOOK_DIR}" ] \
       || [ "true" = "${BUILDER_CONFIG["DISABLE_CONSOLE_CONF"]}" ] \
       || [ "true" = "${BUILDER_CONFIG["ENABLE_EARLY_GETTY"]}" ] \
       || [ "${BUILDER_CONFIG["JOURNAL_STORAGE_PERSISTENT"]}" = "true" ] \
       || [ "${BUILDER_CONFIG["DISABLE_SSH_SERVER"]}" = "true" ] \
       || [ -n "${BUILDER_CONFIG["HOSTNAME"]}" ] \
       || [ -n "${SSH_PUB_KEY_FILES}" ] \
       || [ -n "${BUILDER_CONFIG["CUSTOM_OVERLAY"]}" ]; then
         echo "!!! Ignoring any passed overlays, not yet supported for UC20 !!!!!"
    fi
fi

# create system boot if needed
create_system_boot_partition_image

# prepare output directory
if [ -d ${BUILDER_CONFIG["OUTPUT_DIR"]} ]; then
    print_debug 2 "Cleaning output directory [${BUILDER_CONFIG["OUTPUT_DIR"]}]"
    rm -rf ${BUILDER_CONFIG["OUTPUT_DIR"]}
fi
mkdir -p ${BUILDER_CONFIG["OUTPUT_DIR"]}

gadget_yaml="${BUILDER_CONFIG["WORK_DIR"]}/gadget/meta/gadget.yaml"

# UC16/18 can have custom or normal part schema
if [ "${BUILDER_CONFIG["UC20"]}" = "true" ]; then
  # create ubuntu-seed image
  create_uc20_seed_partition_image
else
  # check if gadget has partition 'seed', for factory reset
  if [ -n "$(yq r ${gadget_yaml} 'volumes.*.*.(name==seed).name')" ]; then
    # creating seed partition image
    create_seed_partition_image
  else
    # create write partition image
    create_writable_partition_image
  fi
fi
# copy release files to output directory or run amba image build
if [ "${BUILDER_CONFIG["AMBOOT"]}" = "true" ]; then
  run_amba_image_build
else
  copy_release_files
fi

# create image manifest
generate_manifest

print_debug 0 "\nOutput available in: '${BUILDER_CONFIG["OUTPUT_DIR"]}'"
