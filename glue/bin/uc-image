#!/bin/bash

# This program is free software: you can redistribute it and/or modify it
# under the terms of the the GNU General Public License version 3, as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranties of
# MERCHANTABILITY, SATISFACTORY QUALITY or FITNESS FOR A PARTICULAR
# PURPOSE.  See the applicable version of the GNU General Public
# License for more details.
#.
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Copyright (C) 2020 Canonical, Ltd.

# this can be used to validate if there is newer version available
SCRIPT_VERSION=4.10.2

unset BUILDER_CONFIG
declare -A BUILDER_CONFIG

if [ -n "$(uname -a | grep Darwin)" ]; then
  READLINK="greadlink"
  # do not use fakeroot by default
  BUILDER_CONFIG["FAKEROOT"]=""
else
  READLINK="readlink"
  # use fakeroot by default
  BUILDER_CONFIG["FAKEROOT"]="fakeroot"
fi

# fill in default values
BUILDER_CONFIG["OUTPUT_DIR"]="$(${READLINK} -f uc-db-build)"
BUILDER_CONFIG["BUILDER_DEBUG"]="${DB_BUILDER_DEBUG}"
BUILDER_CONFIG["SEARCH_PATH"]="${DB_BUILDER_PATH}"

# special files to be copied from gadget snap if any exists
# they are typically not mapped to any partition, so won't be picked based on
# gadget yaml
# uc.lst: uuu flash config file
# gpt_* : partition table files
# Qualcomm flash supporting files flashall, rawprogram*, patch*, prog_fire*
BUILDER_CONFIG["SPECIAL_GADGET_ASSETS"]="uc.lst gpt*.bin prog*_firehose*.* flashall rawprogram*.xml patch*.xml"

# delete all logs
rm -rf $(dirname $(mktemp -u -t uc-image-builder-XXXX))/uc-image-builder-* 2> /dev/null
BUILDER_CONFIG["TMP_LOG_FILE"]="$(mktemp -t uc-image-builder-XXXX)"
[ -z "${BUILDER_CONFIG["BUILDER_DEBUG"]}" ] && BUILDER_CONFIG["BUILDER_DEBUG"]=1
[ -n "${DB_BUILDER_WORK_DIR}" ] && BUILDER_CONFIG["WORK_DIR"]=${DB_BUILDER_WORK_DIR}
[ -n "${DB_BUILDER_OUTPUT_DIR}" ] && BUILDER_CONFIG["OUTPUT_DIR"]=$(${READLINK} -f ${DB_BUILDER_OUTPUT_DIR})

# boot assets candidate directories in gadget snap
BOOT_ASSETS_CANDIDATES="blobs boot-assets assets"

SNAP_REQUIRED_INTERFACES="home mount-observe network-observe ssh-public-keys"

# print help
print_help () {
    echo "Builder for UbuntuCore for images supporting fastboot like flash tool"
    echo ""
    echo "positional arguments:"
    echo "  model_assertion       Path to the model assertion file. This argument must"
    echo "                        be given unless the state machine is being resumed, in"
    echo "                        which case it cannot be given."
    echo ""
    echo "optional arguments:"
    echo "  -h, --help            show this help message and exit"
    echo "  --snap SNAP           Install an extra snap."
    echo "                        This is passed through to 'snap prepare-image'. The snap argument can include"
    echo "                        additional information about the track|risk channel/branch"
    echo "                        with the following syntax: <snap>=<track|channel/branch>"
    echo "                        examples: --snap go=1.14|stable"
    echo "                                  --snap avahi.snap"
    echo "  -c CHANNEL, --channel CHANNEL"
    echo "                        The snap channel to use, one of stable/candidate/beta/edge"
    echo "                        stable channel is assumed if no channel is defined"
    echo "                        example: -c edge"
    echo "  -d, --debug           print debug"
    echo "  -dd                   print verbose debugs"
    echo "  -v|--version"
    echo "                        print version of the script"
    echo ""
    echo "Common options:"
    echo "!!! Not all options are available when building Ubuntu Core 20 image!!!"
    echo "  --disk-info DISK-INFO-CONTENTS"
    echo "                        File to be used as .disk/info on the image's rootfs."
    echo "                        This file can contain useful information about the"
    echo "                        target image, like image identification data, system"
    echo "                        name, build timestamp etc."
    echo "  -O DIRECTORY, --output-dir DIRECTORY"
    echo "                        The directory in which to put generated disk image"
    echo "                        files."
    echo "  -w DIRECTORY, --workdir DIRECTORY"
    echo "                        The working directory in which to download and unpack"
    echo "                        all the source/snap files for the image. This directory can"
    echo "                        exist or not, and it is not removed after this program"
    echo "                        exits. If not given, a temporary working directory is"
    echo "                        used instead under /tmp"
    echo " --build-raw            Build raw image, instead of sparse one"
    echo "                        Cannot be used in combination with --use-android-fs-tools!!!"
    echo " --use-android-fs-tools Use android make_ext4fs instead of mkfs.ext4"
    echo " --build-seed-image     Build compressed ubuntu-seed fs image release"
    echo ""
    echo "Following options are only available to Ubuntu Core 16 and 18 images"
    echo "  --netplan-config NETPLAN-CONFIG-FILE"
    echo "                        Network config for netplan, should not be combined with --network-config"
    echo "  --cloud-init USER-DATA-FILE"
    echo "                        cloud-config data to be copied to the image"
    echo "  --network-config NETWORK-CONFIG-FILE"
    echo "                        Network config for cloud init"
    echo "  --disable-console-conf"
    echo "                        disable first boot console configuration"
    echo "  --auto-import-assertion  ASSERTION FILE"
    echo "                        Auto import assertion file to be included in root of main writable partiton."
    echo "                        This assertion is imported once system is fully seeded"
    echo "                        Passed file does not need to have correct file name, it will be renamed"
    echo "  -o, --overlay"
    echo "                        Directory to overlay on top of rootfs"
    echo "                        !!! this option cannot be guaranteed !!!"
    echo "                            use only on your own risk!"
    echo "                            intended for device enablement phase"
    echo " --backdoor U           Create backdoor (only uc-16/18 images) with user U, supports additional parameters"
    echo "     --import-id U      backdoor: use 'ssh-import-id' to get ssh public keys"
    echo "                        may be used more than once."
    echo "     --password P       backdoor: password, implies --password-auth"
    echo "     --password-auth    backdoor: enable password auth"
    echo "     --pubkeys F        backdoor: add public keys from file F"
    echo "                                  default: ~/.ssh/id_rsa.pub unless --password"
    echo "                                  or --import-id specified"
    echo " --journald-storage-persistent"
    echo "                        Configure system to use persistent storage for journald logs instead of default volatile settings"
    echo " --disable-ssh-server"
    echo "                        Disable system's ssh server from very beginning of the first boot"
    echo " --seed-root-ssh-authorized-keys"
    echo "                        populate root's authorized_keys (/root/.ssh/authorized_keys) with passed"
    echo "                        public key(s)"
    echo "                        example: --seed-root-ssh-authorized-keys <key 1> [key 2]"
    echo "                        to enable early boot loggin, combine with use of --enable-early-getty"
    echo " --enable-early-getty"
    echo "                        Forcefull disabling of console conf and early enablement of getty"
    echo "                        !!! Use this only for boot debugging, not suitable for production images"
    echo "                        This option as consequence disables console-conf"
    echo " --set-hostname HOSTNAME"
    echo "                        Set initial hostname to be used at first boot"
    echo "                        !!! This feature is not guarteed as it's using image overlay"
    echo ""
    echo "Builder supports default settings passed through environment variables"
    echo "Supported env variables:"
    echo "    DB_BUILDER_PATH:       Colon separated search paths to use to search for passed file parameters"
    echo "                           if not provided with absolute or relative path."
    echo "                           First successful find is used."
    echo "                           This search path is used for model assertions, snaps, network configs, auto-import-assertion, netplan-config"
    echo "    DB_BUILDER_DEBUG:      Default log level"
    echo "                           0 - no logs, 3 - detailed logs. Default level is '1'"
    echo "    DB_BUILDER_WORK_DIR:   Default work directory to be used"
    echo "                           If not defined or passed as param, tmp directory is created"
    echo "    DB_BUILDER_OUTPUT_DIR: Default output directory"
    echo "                           If not defined or passed as param, 'uc-db-build' directory will be created in current directory"
}

# normalize version
normalize_version () {
   echo "$@" | awk -F. '{ printf("%d%03d%03d%03d\n", $1,$2,$3,$4); }'
}

# provision macOS
provision_macOS_system () {
  if [ -n "$(uname -a | grep Darwin)" ]; then
    ## building on macOS, check if dependencies are installed

    # first check brew cellars, required cellars: e2fsprogs, simg2img, squashfs, dosfstools
    if [ ! -f "$(which brew)" ]; then
      echo "This system has no brew installed. There is no way to install dependencies required for image building"
      echo "see https://brew.sh"
      exit 0
    fi
    echo -e "\nChecking system dependencies"
    # brew list is very slow, so check for files instead
    declare -A UC_BUILD_DEPENDENCIES
    UC_BUILD_DEPENDENCIES["coreutils"]="realpath"
    UC_BUILD_DEPENDENCIES["e2fsprogs"]="mkfs.ext4"
    UC_BUILD_DEPENDENCIES["simg2img"]="img2simg"
    UC_BUILD_DEPENDENCIES["squashfs"]="mksquashfs"
    UC_BUILD_DEPENDENCIES["dosfstools"]="mkfs.vfat"
    # UC_BUILD_DEPENDENCIES["fakeroot"]="fakeroot" not yes supported by macOS 12.x
    UC_BUILD_DEPENDENCIES["mtools"]="mcopy"
    UC_BUILD_DEPENDENCIES["wget"]="wget"
    UC_BUILD_DEPENDENCIES["yq"]="yq"
    UC_BUILD_PYTHON_DEPENDENCIES["ssh-import-id"]="ssh-import-id"

    # handle build dependecies installed by brew
    for pckg in "${!UC_BUILD_DEPENDENCIES[@]}"
    do
      if [ ! -f "$(which  ${UC_BUILD_DEPENDENCIES[${pckg}]})" ]; then
        echo -e "installing brew cellar ${pckg}"
        brew install ${pckg}
      fi
    done

    # check if we have snap client binary
    if [ ! ${HOME}/bin/snap ]; then
      echo "Downloadig snap client...."
      mkdir -p ${HOME}/bin
      wget https://people.canonical.com/~okubik/snap.macOS -o ${HOME}/bin/snap
      chmod +x ${HOME}/bin/snap
      echo "Downloaded version of snap client:"
      snap version
    fi

    # update script if there is never version
    local url="https://raw.githubusercontent.com/kubiko/uc-image/master/glue/bin/uc-image"
    local latest_version=$(curl -s ${url} | grep SCRIPT_VERSION= | head -n1 | awk -F '=' '{print $2}')
    if [ $(normalize_version ${SCRIPT_VERSION}) -ge $(normalize_version ${latest_version}) ]; then
      echo -e "Script version is up to date\n"
    else
      echo -e "!!! Script is outdated, download new one from ${url} !!!\n"
      exit 0
    fi
  fi
}

# check snaps interfaces are connected before progressing
check_snap_environment () {
  # are we even running in snap confinement
  if [ -z "$(env | grep SNAP_INSTANCE_NAME)" ]; then
    echo "Detected non snap environment execution (running unconfined)"
    return
  fi
  # ensure we have all the interfaces connected
  local missing_connections=""
  for plug in ${SNAP_REQUIRED_INTERFACES}
  do
    if ! snapctl is-connected ${plug}; then
      missing_connections="${missing_connections}${plug} "
    fi
  done

  if [ -n "${missing_connections}" ]; then
    echo "Snap does not have connected plugs required for its function, please connected them"
    echo "By running:"
    for p in ${missing_connections}
    do
      echo -e "\t$ snap connect ${SNAP_INSTANCE_NAME}:${p}"
    done
    exit 0
  fi

  # check we are not running as root
  if [ "$USER" =  "root" ]; then
    echo "Please do not run with sudo, no need for this"
    exit 0
  fi
}

# print debug log
print_debug () {
  local level=${1}
  shift
  [ "${BUILDER_CONFIG["BUILDER_DEBUG"]}" -ge "${level}" ] && echo -e "$@"
  # if work dir does not exist yet, log to tmp log file
  if [ -e "${BUILDER_CONFIG["TMP_LOG_FILE"]}" ]; then
    echo -e "$@" >> ${BUILDER_CONFIG["TMP_LOG_FILE"]}
  else
    echo -e "$@" >> ${BUILDER_CONFIG["WORK_DIR"]}/builder.log
  fi
}

# print builder config if debug log
print_builder_config () {
  if [ "${BUILDER_CONFIG["BUILDER_DEBUG"]}" -ge "2" ]; then
    print_debug 1 "Builder configuration:"
    for i in "${!BUILDER_CONFIG[@]}"; do
      print_debug 1 "\t$i = ${BUILDER_CONFIG[$i]}"
    done
    # print empty line
    echo ""
  fi
}

# prepare work directory
prepare_work_directory () {
  # first clean previus tmp directories
  rm -rf $(dirname $(mktemp -u -d -t uc-db-workdir-XXXXX))/uc-db-workdir-*
  # if work directory is not defined, use tmp one
  if [ -z "${BUILDER_CONFIG["WORK_DIR"]}" ]; then
    # work dir not defined create tmp one
    BUILDER_CONFIG["WORK_DIR"]=$(mktemp -d -t uc-db-workdir-XXXX)
    mkdir -p ${BUILDER_CONFIG["WORK_DIR"]}
    print_debug 2 "Creating temp work directory: ${BUILDER_CONFIG["WORK_DIR"]}"
  else
    # make sure dir exists
    if [ -d ${BUILDER_CONFIG["WORK_DIR"]} ]; then
        print_debug 2 "Cleaning old build directory [${BUILDER_CONFIG["WORK_DIR"]}]"
        rm -rf ${BUILDER_CONFIG["WORK_DIR"]}
    fi
    mkdir -p ${BUILDER_CONFIG["WORK_DIR"]}
  fi
}

# dtermine if we are building for UC20
determine_uc2x() {
  print_debug 3 "determine_uc2x"
  # we can have true uc20 and we can have uc20 with disk and boot as uc16/18
  # grade keyword is only defined for tru uc20
  if [ -n "$(grep 'base: core20' ${BUILDER_CONFIG["MODEL_ASSERTION"]} 2> /dev/null)" ]; then
    if [ -n "$(grep '^grade:' ${BUILDER_CONFIG["MODEL_ASSERTION"]} 2> /dev/null)" ]; then
      print_debug 2 "Target Ubuntu Core 20+ detected"
      BUILDER_CONFIG["UC20"]="true"
    else
      print_debug 2 "Target Ubuntu Core 20 with UC18 disk and boot style!!"
      BUILDER_CONFIG["UC20"]="false"
    fi
  else
    print_debug 2 "Target PRE Ubuntu Core 20 detected"
    BUILDER_CONFIG["UC20"]="false"
  fi
}

# determine bootloader type
determine_bootloader () {
  print_debug 3 "determine_bootloader"
  # determine boot assets dir
  for ba in ${BOOT_ASSETS_CANDIDATES}
  do
    if [ -d ${BUILDER_CONFIG["GADGET_DIR"]}/${ba} ]; then
      BUILDER_CONFIG["BOOT_ASSETS"]="${BUILDER_CONFIG["GADGET_DIR"]}/${ba}"
      break
    fi
  done

  print_debug 5 "bootloader: yq eval '.volumes.[] | select(.bootloader) | .bootloader' ${BUILDER_CONFIG["GADGET_YAML"]}"
  BUILDER_CONFIG["BOOTLOADER"]="$(yq eval '.volumes.[] | select(.bootloader) | .bootloader' ${BUILDER_CONFIG["GADGET_YAML"]})"
  print_debug 5 "BUILDER_CONFIG["BOOTLOADER"]=${BUILDER_CONFIG["BOOTLOADER"]}"
  # UC20 behaves differently from UC16/18
  if [ "${BUILDER_CONFIG["UC20"]}" = "true" ]; then
    BUILDER_CONFIG["IMAGE_ROOT"]=${BUILDER_CONFIG["WORK_DIR"]}/system-seed
  else
    BUILDER_CONFIG["IMAGE_ROOT"]=${BUILDER_CONFIG["WORK_DIR"]}/image
    mkdir -p ${BUILDER_CONFIG["WORK_DIR"]}/root/system-data/
  fi

  print_debug 3 "BUILDER_CONFIG["IMAGE_ROOT"]=${BUILDER_CONFIG["IMAGE_ROOT"]}"
  # we can have u-boot, lk, or special case of lk amboot(Ambarella amboot)
  if [ "${BUILDER_CONFIG["BOOTLOADER"]}" = "u-boot" ]; then
    ## u-boot
    BUILDER_CONFIG["BOOTLOADER"]="u-boot"
    if [ "${BUILDER_CONFIG["UC20"]}" != "true" ]; then
      mv ${BUILDER_CONFIG["IMAGE_ROOT"]}/boot/uboot ${BUILDER_CONFIG["WORK_DIR"]}/system-boot
    fi
    # check if we have defined dtb
    BUILDER_CONFIG["DTB"]=$(yq eval '. | select(.device-tree) | .device-tree' ${BUILDER_CONFIG["GADGET_YAML"]})
  elif [ "${BUILDER_CONFIG["BOOTLOADER"]}" = "lk" ]; then
    ## lk
    BUILDER_CONFIG["BOOTLOADER"]="lk"
    mv ${BUILDER_CONFIG["IMAGE_ROOT"]}/boot/lk ${BUILDER_CONFIG["WORK_DIR"]}/lk
    # check if this is amboot special case
    if [ -d ${BUILDER_CONFIG["BOOT_ASSETS"]}/amboot ]; then
      # set some configuratoon for amboot case
      BUILDER_CONFIG["BUILD_RAW"]="true"
      BUILDER_CONFIG["AMBOOT"]="true"
    fi
  else
    print_debug 0 "Unrecognised bootloader, exiting"
    exit 0
  fi

  if [ "${BUILDER_CONFIG["UC20"]}" != "true" ]; then
    mv ${BUILDER_CONFIG["IMAGE_ROOT"]}/* ${BUILDER_CONFIG["WORK_DIR"]}/root/system-data/
    # set new image root
    BUILDER_CONFIG["IMAGE_ROOT"]=${BUILDER_CONFIG["WORK_DIR"]}/root
  fi
  print_debug 1 "\nDetected bootloader: ${BUILDER_CONFIG["BOOTLOADER"]}"
}

# validate passed parameter is file
# if passed string is not file with relative/absolute path
# BUILDER_CONFIG["SEARCH_PATH"] variable is used as search path to look for the file
# first hit is used
# function returns absolute path to the file if file is validated or none
validate_file () {
    local file=${1}
    if [ -n "${file}" ]; then
        if [ ! -e ${file} ]; then
            # only use when we actually have search path
            if [ -n "${BUILDER_CONFIG["SEARCH_PATH"]}" ]; then
                IFS=":"
                for p in ${BUILDER_CONFIG["SEARCH_PATH"]}
                do
                    if [ -e ${p}/${file} ]; then
                        echo $(${READLINK} -f ${p}/${file})
                        return
                    fi
                done
            fi
        else
            echo $(${READLINK} -f ${file})
        fi
    fi
}

# validate passed snap
# passed snap can be either snap name from store or local file
# function return either snap name or absolute path to snap file
validate_snap () {
    local s="${1}"
    if [ "${s: -5}" = ".snap" ]; then
        # check if local snap file exists
        echo "$(validate_file ${s})"
    else
        # store snap
        echo "${s}"
    fi
}

# normalise passed size to kilo bytes
# passed size can be in Kilo(K|k), Mega(M|m), Giga(G\g) bytes
# if not specified value is assumed in bytes
normalise_size_to_kb () {
  local size=${1}
  case $size in
     (0)  size="0" ;;
     (*G | *g) size=$(expr $(echo $size | sed -e 's/G//g' -e 's/g//g') \* 1024 \* 1024) ;;
     (*M | *m) size=$(expr $(echo $size | sed -e 's/M//g' -e 's/m//g') \* 1024) ;;
     (*K | *k) size=$(echo $size | sed -e 's/K//g' -e 's/k//g') ;;
     (*) size=$(expr $size / 1024) ;;
  esac
  echo ${size}
}

# seed cloud init user_data
# if no cloud init user data is passed do nothing
seed_cloud_init_user_data () {
  print_debug 5 "seed_cloud_init_user_data(${BUILDER_CONFIG["CLOUD_INIT_USER_DATA"]})"
  if [ -n "${BUILDER_CONFIG["CLOUD_INIT_USER_DATA"]}" ]; then
    print_debug 1 "\nUsing passed cloud init user data configuration: [${BUILDER_CONFIG["CLOUD_INIT_USER_DATA"]}]"
    mkdir -p ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/var/lib/cloud/seed/nocloud-net
    cp ${BUILDER_CONFIG["CLOUD_INIT_USER_DATA"]} ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/var/lib/cloud/seed/nocloud-net/user-data
    echo "instance-id: nocloud-static" > ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/var/lib/cloud/seed/nocloud-net/meta-data
  fi
}

# seed cloud init network config
# if no cloud init network config is passed do nothing
seed_cloud_init_net_config () {
  print_debug 5 "seed_cloud_init_net_config(${BUILDER_CONFIG["CLOUD_INIT_NETWORK_CONFIG"]})"
  if [ -n "${BUILDER_CONFIG["CLOUD_INIT_NETWORK_CONFIG"]}" ]; then
    print_debug 1 "\nUsing passed cloud init network configuration: [${BUILDER_CONFIG["CLOUD_INIT_NETWORK_CONFIG"]}]"
    mkdir -p ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/var/lib/cloud/seed/nocloud-net
    cp ${BUILDER_CONFIG["CLOUD_INIT_NETWORK_CONFIG"]} ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/var/lib/cloud/seed/nocloud-net/network-config
    echo "instance-id: nocloud-static" > ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/var/lib/cloud/seed/nocloud-net/meta-data
  fi
}

# seed netplan network config if provided
# if no netplan config is passed do nothing
seed_netplan_config () {
  print_debug 5 "seed_netplan_config(${BUILDER_CONFIG["NETPLAN_CONF"]})"
  if [ -n "${BUILDER_CONFIG["NETPLAN_CONF"]}" ]; then
    print_debug 1 "\nUsing passed netplan configuration: [${BUILDER_CONFIG["NETPLAN_CONF"]}]"
    mkdir -p ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/etc/netplan
    cp ${BUILDER_CONFIG["NETPLAN_CONF"]} ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/etc/netplan/00-snapd-config.yaml
  fi
}

# seed passed assertion as auto import assertion
# one assertion can be passed
# if no assertion is passed do nothing
seed_auto_import_assertion () {
  print_debug 5 "seed_auto_import_assertion(${BUILDER_CONFIG["ASSERTION_IMPORT"]})"
  if [ -n "${BUILDER_CONFIG["ASSERTION_IMPORT"]}" ]; then
    print_debug 1 "\nImporting passed assertion file: [${BUILDER_CONFIG["ASSERTION_IMPORT"]}]"
    cp ${BUILDER_CONFIG["ASSERTION_IMPORT"]} ${BUILDER_CONFIG["IMAGE_ROOT"]}/auto-import.assert
  fi
}

# disable console conf if requested
# if disable console conf is not requested, do nothing
disable_console_conf () {
  print_debug 5 "disable_console_conf(${BUILDER_CONFIG["DISABLE_CONSOLE_CONF"]})"
  if [ "true" = "${BUILDER_CONFIG["DISABLE_CONSOLE_CONF"]}" ]; then
    print_debug 1 "\nDisabling console conf"
    mkdir -p ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/var/lib/console-conf
    touch ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/var/lib/console-conf/complete
  fi
}

# add build timestamp if provided
# if no buildstamp is passed do nothing
disk_info_contents () {
  print_debug 5 "disk_info_contents(${BUILDER_CONFIG["DISK_INFO_CONTENTS"]})"
  if [ -n "${BUILDER_CONFIG["DISK_INFO_CONTENTS"]}" ]; then
    print_debug 1 "\nUsing passed disk info contents: [${BUILDER_CONFIG["DISK_INFO_CONTENTS"]}]"
    if [ "${BUILDER_CONFIG["UC20"]}" = "true" ]; then
      mkdir -p ${BUILDER_CONFIG["IMAGE_ROOT"]}/.disk
      cp ${BUILDER_CONFIG["DISK_INFO_CONTENTS"]} ${BUILDER_CONFIG["IMAGE_ROOT"]}/.disk/info
    else
      mkdir -p ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/etc
      cp ${BUILDER_CONFIG["DISK_INFO_CONTENTS"]} ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/etc
    fi
  fi
}

# enable early getty if requested
# if no early getty is not requested, do nothing
enable_early_getty () {
  print_debug 5 "enable_early_getty(${BUILDER_CONFIG["ENABLE_EARLY_GETTY"]})"
  if [ "true" = "${BUILDER_CONFIG["ENABLE_EARLY_GETTY"]}" ]; then
    print_debug 1 "\nEnabling early getty"
    mkdir -p ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/etc/systemd/system/serial-getty@.service.d/
    mkdir -p ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/etc/systemd/system/getty@.service.d/
    ln -s /dev/null ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/etc/systemd/system/console-conf@.service
    ln -s /dev/null ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/etc/systemd/system/serial-console-conf@.service
    echo -e "[Service]\nExecStartPre=" > ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/etc/systemd/system/serial-getty@.service.d/z-console-conf-serial.conf
    echo -e "[Service]\nExecStartPre=" > ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/etc/systemd/system/getty@.service.d/z-console-conf.conf
  fi
}

# check if device should be configured with persistent journal storage
# if no persistent journal is passed do nothing
enable_persisten_journal () {
  print_debug 5 "enable_persisten_journal(${BUILDER_CONFIG["JOURNAL_STORAGE_PERSISTENT"]})"
  if [ "${BUILDER_CONFIG["JOURNAL_STORAGE_PERSISTENT"]}" = "true" ]; then
    print_debug 1 "\nSwitching journald to use persistent storage"
    mkdir -p ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/var/log/journal
  fi
}

# check if system's ssh server should be disabled
# if disable ssh server is not requested do nothing
disable_ssh_server () {
  print_debug 5 "disable_ssh_server(${BUILDER_CONFIG["DISABLE_SSH_SERVER"]})"
  if [ "${BUILDER_CONFIG["DISABLE_SSH_SERVER"]}" = "true" ]; then
    print_debug 1 "\nDisabling system ssh server"
    mkdir -p ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/etc/ssh
    touch ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/etc/ssh/sshd_not_to_be_run
  fi
}

# check if we should set default hostname
# if no hostname is passed do nothing
seed_hostname () {
  print_debug 5 "seed_hostname(${BUILDER_CONFIG["HOSTNAME"]})"
  if [ -n "${BUILDER_CONFIG["HOSTNAME"]}" ]; then
    print_debug 1 "\nSetting initial hostname to [ ${BUILDER_CONFIG["HOSTNAME"]} ]"
    mkdir -p ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/etc/
    echo ${BUILDER_CONFIG["HOSTNAME"]} > ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/etc/hostname
  fi
}

# check if we should seed authorized ssh kyes for root user
# if no root authorised keys are passed do nothing
seed_root_authorized_keys () {
  print_debug 5 "seed_root_authorized_keys(${SSH_PUB_KEY_FILES})"
  if [ -n "${SSH_PUB_KEY_FILES}" ]; then
    print_debug 1 "\nSeeding root authorized ssh keys [${SSH_PUB_KEY_FILES}]"
    SSH_DIR="${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/root/.ssh"
    mkdir -p ${SSH_DIR}
    chmod 700 ${SSH_DIR}
    AUTHORIZED_KEYS="${SSH_DIR}/authorized_keys"
    for key in ${SSH_PUB_KEY_FILES}
    do
      if [ -f ${key} ]; then
          cat ${key} >> ${AUTHORIZED_KEYS}
      fi
    done
    chmod 600 ${AUTHORIZED_KEYS}
  fi
}

# Apply custom overlay if there are some
# if no custom overlay is passed do nothing
seed_custom_overlay () {
  print_debug 5 "seed_custom_overlay(${BUILDER_CONFIG["CUSTOM_OVERLAY"]})"
  if [ -n "${BUILDER_CONFIG["CUSTOM_OVERLAY"]}" ];then
    print_debug 1 "Applying custom overlay"
    cp -r ${BUILDER_CONFIG["CUSTOM_OVERLAY"]}/* ${BUILDER_CONFIG["IMAGE_ROOT"]}
  fi
}

# create backdoor into the image if defined
create_backdoor() {
  print_debug 5 "create_backdoor(${BUILDER_CONFIG["BACKDOOR_USER"]}, ${BUILDER_CONFIG["BACKDOOR_PARAMS"]})"
  if [ -n "${BUILDER_CONFIG["BACKDOOR_USER"]}" ];then
    print_debug 1 "Creating backdoor for user ${BUILDER_CONFIG["BACKDOOR_USER"]}"
    backdoor-image \
      --user ${BUILDER_CONFIG["BACKDOOR_USER"]} \
      ${BUILDER_CONFIG["BACKDOOR_PARAMS"]} \
      ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data
  fi
}

# create image for the volume
# based on config, this can be ext4 file system image, or tarball
# passed parameters (not all are used, depending on created volume image)
# - volume source
# - target volume image, without file type, it will be added
# - volume label
# - volume size
create_disk_image() {
  local volume_source="${1}"
  local volume_image="${2}"
  local volume_label="${3}"
  local volume_size="${4}"
  # build ext4 disk image
  if [ "${BUILDER_CONFIG["USE_ANDROID_FS_TOOLS"]}" = "true" ]; then
    print_debug 2 "${BUILDER_CONFIG["FAKEROOT"]} make_ext4fs -L ${volume_label} -l ${volume_size} -s ${volume_image}.img ${volume_source}"
    ${BUILDER_CONFIG["FAKEROOT"]} make_ext4fs \
       -L ${volume_label} \
       -l ${volume_size} \
       -s \
       ${volume_image}.img \
       ${volume_source} 2>&1 | tee -a ${BUILDER_CONFIG["WORK_DIR"]}/builder.log
  else
    print_debug 2 "${BUILDER_CONFIG["FAKEROOT"]} mkfs.ext4 -O -metadata_csum -T default -E root_owner=0:0 -O uninit_bg -L ${volume_label} -d ${volume_source} ${volume_image}.raw ${volume_size}"
    ${BUILDER_CONFIG["FAKEROOT"]} mkfs.ext4 \
      -O \
      -metadata_csum \
      -T default \
      -E root_owner=0:0 \
      -O uninit_bg \
      -L ${volume_label} \
      -d ${volume_source} ${volume_image}.raw \
      ${volume_size} 2>&1 | tee -a ${BUILDER_CONFIG["WORK_DIR"]}/builder.log
    if [ ! -f ${volume_image}.raw ]; then
      print_debug 1 "\nImage creation for ${volume_label} partiton failed, bailing out!!!"
      exit 0
    fi
    # build sparse if needed
    if [ "${BUILDER_CONFIG["BUILD_SEED_IMAGE"]}" = "true" ]; then
      print_debug 1 "\nCompressing image for ${volume_label}"
      print_debug 2 "xz -c ${volume_image}.raw  > ${volume_image}.img.xz"
      xz -c ${volume_image}.raw  > ${volume_image}.img.xz
    else
      print_debug 1 "\nCreate sparse image for ${volume_label}"
      print_debug 2 "img2simg ${volume_image}.raw ${volume_image}.img"
      img2simg \
        ${volume_image}.raw \
        ${volume_image}.img 2>&1 | tee -a ${BUILDER_CONFIG["WORK_DIR"]}/builder.log
    fi
  fi
  if [ ! -f ${volume_image}.img ]; then
    print_debug 1 "\nImage creation for ${volume_label} partiton failed, bailing out!!!"
    exit 0
  fi

}

# create system-boot partition if needed
create_system_boot_partition_image () {
  # u-boot bootloader is using dedicated 'system-boot' partition
  if [ ! "${BUILDER_CONFIG["BOOTLOADER"]}" = "u-boot" ]; then
    return
  fi
  # check if we need to copy any assets from gadget first
  local source="$(yq eval '.volumes.[].structure.[] | select(.role == "system-boot") | .content.[].source' ${BUILDER_CONFIG["GADGET_YAML"]})"
  if [ -n "${source}" ]; then
    local target="$(yq eval '.volumes.[].structure.[] | select(.role == "system-boot") | .content.[].target' ${BUILDER_CONFIG["GADGET_YAML"]})"
    if [ -n "${target}" ]; then
      cp -r ${BUILDER_CONFIG["GADGET_DIR"]}/${source} \
            ${BUILDER_CONFIG["WORK_DIR"]}/system-boot/${target}
    fi
  fi
  print_debug 1 "\nCreating image for system-boot"
  dd if=/dev/zero of=${BUILDER_CONFIG["WORK_DIR"]}/system-boot.img bs=1024 count=131072
  ${BUILDER_CONFIG["FAKEROOT"]} mkfs.vfat \
      -s 1 \
      -S 512 \
      -F 32 \
      -n 'system-boot' \
      ${BUILDER_CONFIG["WORK_DIR"]}/system-boot.img 2>&1 | tee -a ${BUILDER_CONFIG["WORK_DIR"]}/builder.log
  mcopy \
      -s \
      -i ${BUILDER_CONFIG["WORK_DIR"]}/system-boot.img \
      ${BUILDER_CONFIG["WORK_DIR"]}/system-boot/* :: 2>&1 | tee -a ${BUILDER_CONFIG["WORK_DIR"]}/builder.log
}

# create seed partition image
create_seed_partition_image () {
  print_debug 1 "\nCreating seed partition image"
  # copy back up files in root/boot

  local seed_size_human=$(yq eval '.volumes.[].structure.[] | select(.name == "seed") | .size' ${BUILDER_CONFIG["GADGET_YAML"]})
  local SEED_SIZE="$(normalise_size_to_kb ${seed_size_human})k"

  create_disk_image \
      ${BUILDER_CONFIG["IMAGE_ROOT"]} \
      ${BUILDER_CONFIG["WORK_DIR"]}/seed \
      "seed" \
      ${SEED_SIZE}
}

# create writable partition image
create_writable_partition_image () {
  # root partition is "writable"
  print_debug 1 "\nCreating image for writable"
  print_debug 2 "Calculating required size of writable partition image"
  # make root size bigger by what be needed for boot backup
  # local root_size=$(find ${BUILDER_CONFIG["IMAGE_ROOT"]} -exec du -s {} + | awk '{total = total + $1}END{printf("%.0fMB",(total / 1024 + 50))}')
  print_debug 3 "IMAGE_ROOT=${BUILDER_CONFIG["IMAGE_ROOT"]}"
  du -sh ${BUILDER_CONFIG["IMAGE_ROOT"]}
  local root_size=$(du -sh ${BUILDER_CONFIG["IMAGE_ROOT"]} | awk '{print $1}')
  # add 20M buffer
  ROOT_SIZE=$(echo ${root_size} | awk '{printf("%.0f",($1+20))}')M
  print_debug 2 "ROOT_SIZE=${ROOT_SIZE}"
  create_disk_image \
      ${BUILDER_CONFIG["IMAGE_ROOT"]} \
      ${BUILDER_CONFIG["WORK_DIR"]}/writable \
      "writable" \
      ${ROOT_SIZE}
}

# create UC20 seed partition image
create_uc20_seed_partition_image () {
  print_debug 1 "\nCreating UC20 seed partition image"

  # calculate ubuntu-seed part size
  local seed_size_human=$(yq eval '.volumes.[].structure.[] | select(.name == "ubuntu-seed") | .size' ${BUILDER_CONFIG["GADGET_YAML"]})
  local SEED_SIZE="$(normalise_size_to_kb ${seed_size_human})k"

  create_disk_image \
      ${BUILDER_CONFIG["IMAGE_ROOT"]} \
      ${BUILDER_CONFIG["WORK_DIR"]}/ubuntu-seed \
      "ubuntu-seed" \
      ${SEED_SIZE}
}

copy_release_files () {
  # copy created disk images to the output directory
  for rf in writable seed ubuntu-seed
  do
    if [ -e ${BUILDER_CONFIG["WORK_DIR"]}/${rf}.img ]; then
      mv ${BUILDER_CONFIG["WORK_DIR"]}/${rf}.img \
         ${BUILDER_CONFIG["OUTPUT_DIR"]}/
    fi
    # check also for imx.xz
    if [ -e ${BUILDER_CONFIG["WORK_DIR"]}/${rf}.img.xz ]; then
      mv ${BUILDER_CONFIG["WORK_DIR"]}/${rf}.img.xz \
         ${BUILDER_CONFIG["OUTPUT_DIR"]}/
    fi
  done

  # copy gadget boot assets files if making normal release
  for f in $(yq eval '.volumes.[].structure.[] | .content.[].image' ${BUILDER_CONFIG["GADGET_YAML"]} | uniq)
  do
    if [ -e ${BUILDER_CONFIG["GADGET_DIR"]}/${f} ]; then
      cp ${BUILDER_CONFIG["GADGET_DIR"]}/${f} \
       ${BUILDER_CONFIG["OUTPUT_DIR"]}/
    fi
  done
  # copy over special files e.g. gpt_*, uc.lst. Assume use of wild cards
  for sf in ${BUILDER_CONFIG["SPECIAL_GADGET_ASSETS"]}
  do
    if compgen -G ${BUILDER_CONFIG["BOOT_ASSETS"]}/${sf} > /dev/null; then
      cp --dereference -r \
        ${BUILDER_CONFIG["BOOT_ASSETS"]}/${sf} \
        ${BUILDER_CONFIG["OUTPUT_DIR"]}/
    fi
  done
  # handle uc-16/18 u-boot case
  if compgen -G ${BUILDER_CONFIG["WORK_DIR"]}/system-boot.* > /dev/null; then
    mv ${BUILDER_CONFIG["WORK_DIR"]}/system-boot.* \
       ${BUILDER_CONFIG["OUTPUT_DIR"]}
  fi
  # if booloader is lk, copy over boot image
  if [ "${BUILDER_CONFIG["BOOTLOADER"]}" = "lk" ]; then
    cp ${BUILDER_CONFIG["WORK_DIR"]}/lk/* \
       ${BUILDER_CONFIG["OUTPUT_DIR"]}/
  fi
}

run_amba_image_build () {
  # gather files for amba image build first
  cp -r ${BUILDER_CONFIG["BOOT_ASSETS"]}/amboot \
        ${BUILDER_CONFIG["WORK_DIR"]}/amba-build
  mkdir -p ${BUILDER_CONFIG["WORK_DIR"]}/amba-build/images
  # copy images from gadget assets, ignore dir warning
  cp ${BUILDER_CONFIG["BOOT_ASSETS"]}/* \
     ${BUILDER_CONFIG["WORK_DIR"]}/amba-build/images 2>/dev/null

  [ -e ${BUILDER_CONFIG["WORK_DIR"]}/writable.raw ] \
    && mv ${BUILDER_CONFIG["WORK_DIR"]}/writable.raw \
          ${BUILDER_CONFIG["WORK_DIR"]}/amba-build/images/lnx.bin
  [ -e ${BUILDER_CONFIG["WORK_DIR"]}/seed.raw ] \
    && mv ${BUILDER_CONFIG["WORK_DIR"]}/seed.raw \
          ${BUILDER_CONFIG["WORK_DIR"]}/amba-build/images/lnx.bin

  [ -e ${BUILDER_CONFIG["WORK_DIR"]}/ubuntu-seed.raw ] \
    && mv ${BUILDER_CONFIG["WORK_DIR"]}/ubuntu-seed.raw \
          ${BUILDER_CONFIG["WORK_DIR"]}/amba-build/images/ubuntu-seed.img

  # add gpt image and rename it
  [ -e ${BUILDER_CONFIG["BOOT_ASSETS"]}/gpt_both0.bin ] \
    && cp ${BUILDER_CONFIG["BOOT_ASSETS"]}/gpt_both0.bin \
          ${BUILDER_CONFIG["WORK_DIR"]}/amba-build/images/gpt_both.bin

  if [ "${BUILDER_CONFIG["BOOTLOADER"]}" = "lk" ]; then
    cp ${BUILDER_CONFIG["WORK_DIR"]}/lk/* \
       ${BUILDER_CONFIG["WORK_DIR"]}/amba-build/images/
  fi

  # run amba image builder script, we need to run it in dir
  # as it has some hardcoded paths
  pushd ${BUILDER_CONFIG["WORK_DIR"]}/amba-build
  ${SNAP}/bin/build-amba-images \
     ${BUILDER_CONFIG["WORK_DIR"]}/amba-build \
     ${BUILDER_CONFIG["WORK_DIR"]}/amba-build/images \
     ${BUILDER_CONFIG["OUTPUT_DIR"]}
  popd
}

# generate image manifest
generate_manifest () {
  local IMAGE_MANIFEST="${BUILDER_CONFIG["OUTPUT_DIR"]}/ubuntu-core-image.manifest"
  if [ "${BUILDER_CONFIG["UC20"]}" != "true" ]; then
    if [ -e ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/var/lib/snapd/seed/assertions/model ]; then
        sed '1,/timestamp/!d' ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/var/lib/snapd/seed/assertions/model > ${IMAGE_MANIFEST}
    fi
    if [ -e ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/var/lib/snapd/seed/seed.yaml ]; then
        sed -e '/snap-id:/d' \
            -e '/contact:/d' \
            -e 's/snaps:/seeded snaps:/g' \
            -e 's/file:.*_\(.*\).snap/revision: \1/' \
            ${BUILDER_CONFIG["IMAGE_ROOT"]}/system-data/var/lib/snapd/seed/seed.yaml \
          >> ${IMAGE_MANIFEST}
    fi
  else
    echo -e "### Ubuntu Core image build ###" > ${IMAGE_MANIFEST}
    echo -e "$(date)" >> ${IMAGE_MANIFEST}
    echo -e "\n### Snap options ###" >> ${IMAGE_MANIFEST}
    cat ${BUILDER_CONFIG["IMAGE_ROOT"]}/systems/*/options.yaml \
      >> ${IMAGE_MANIFEST}
    echo -e "\n### Snap revissions ###" >> ${IMAGE_MANIFEST}
    grep -A7 "type: snap-revision" ${BUILDER_CONFIG["IMAGE_ROOT"]}/systems/*/assertions/snaps \
      >> ${IMAGE_MANIFEST}
    echo -e "\n### Model assertion ###" >> ${IMAGE_MANIFEST}
    cat ${BUILDER_CONFIG["IMAGE_ROOT"]}/systems/*/model >> ${IMAGE_MANIFEST}
    echo -e "\n### snap checksums ###" >> ${IMAGE_MANIFEST}
    if ls ${BUILDER_CONFIG["IMAGE_ROOT"]}/systems/*/snaps/*.snap 1> /dev/null 2>&1; then
      sha256sum ${BUILDER_CONFIG["IMAGE_ROOT"]}/systems/*/snaps/*.snap \
        | awk -F" |/" '{print $1, $NF}' >> ${IMAGE_MANIFEST}
    fi
    if ls ${BUILDER_CONFIG["IMAGE_ROOT"]}/snaps/*.snap 1> /dev/null 2>&1; then
      sha256sum ${BUILDER_CONFIG["IMAGE_ROOT"]}/snaps/*.snap \
        | awk -F" |/" '{print $1, $NF}' >> ${IMAGE_MANIFEST}
    fi
  fi
}

# make sure system is ready before we even start parsing input
provision_macOS_system

# parse passed parameters
while [ "$1" != "" ]; do
    case $1 in
        -c | --channel)
            BUILDER_CONFIG["CHANNEL"]="--channel ${2}"
            shift
            ;;
        --snap=*)
            EX_SNAP=$(echo ${1} | awk -F= '{print $2}')
            BUILDER_CONFIG["SNAPS"]="${BUILDER_CONFIG["SNAPS"]} --snap=$(validate_snap ${EX_SNAP})"
            ;;
        --snap)
            BUILDER_CONFIG["SNAPS"]="${BUILDER_CONFIG["SNAPS"]} --snap=$(validate_snap ${2})"
            shift
            ;;
        -O | --output-dir)
            BUILDER_CONFIG["OUTPUT_DIR"]="$(${READLINK} -f ${2})"
            if [ -z "${BUILDER_CONFIG["OUTPUT_DIR"]}" ]; then
              print_debug 0 "Passed output directory cannot be created!!"
              exit
            fi
            shift
            ;;
        -w | --workdir)
            BUILDER_CONFIG["WORK_DIR"]="$(${READLINK} -f ${2})"
            shift
            ;;
        --netplan-config)
            f=$(validate_file ${2})
            if [ -n "${f}" ] && [ -f ${f} ]; then
                BUILDER_CONFIG["NETPLAN_CONF"]="${f}"
            else
                print_debug 0 "wrong netplan config file was passed [ ${2} ]"
                exit
            fi
            shift
            ;;
        --cloud-init)
            f=$(validate_file ${2})
            if [ -n "${f}" ] && [ -f ${f} ]; then
                BUILDER_CONFIG["CLOUD_INIT_USER_DATA"]="${f}"
            else
                print_debug 0 "wrong cloud init user data file was passed [ ${2} ]"
                exit
            fi
            shift
            ;;
        --network-config)
            f=$(validate_file ${2})
            if [ -n "${f}" ] && [ -f ${f} ]; then
                BUILDER_CONFIG["CLOUD_INIT_NETWORK_CONFIG"]="${f}"
            else
                print_debug 0 "wrong network config for cloud init was passed [ ${2} ]"
                exit
            fi
            shift
            ;;
        --auto-import-assertion)
            f=$(validate_file ${2})
            if [ -n "${f}" ] && [ -f ${f} ]; then
                 BUILDER_CONFIG["ASSERTION_IMPORT"]="${f}"
            else
                 print_debug 0 "wrong assertion file to import was passed [ ${2} ]"
                 exit
            fi
            shift
            ;;
        --disable-console-conf)
            BUILDER_CONFIG["DISABLE_CONSOLE_CONF"]="true"
            ;;
        --disk-info)
            f=$(validate_file ${2})
            if [ -n "${f}" ] && [ -f ${f} ]; then
                BUILDER_CONFIG["DISK_INFO_CONTENTS"]="${f}"
            else
                print_debug 0 "wrong disk info file was passed [ ${2} ]"
                exit
            fi
            shift
            ;;
        -o | --overlay)
            if [ -n "${2}" ] && [ -d ${2} ]; then
                BUILDER_CONFIG["CUSTOM_OVERLAY"]="$(${READLINK} -f ${2})"
                print_debug 0 "!!! This function is not guaranteed, use on own risk !!!"
            else
                print_debug 0 "wrong overlay directory passed [ ${2} ]"
                exit
            fi
            shift
            ;;
        --help | -h)
            print_help
            exit
            ;;
        --build-raw)
            BUILDER_CONFIG["BUILD_RAW"]="true"
            ;;
        --use-android-fs-tools)
            BUILDER_CONFIG["USE_ANDROID_FS_TOOLS"]="true"
            ;;
        --build-seed-image)
            BUILDER_CONFIG["BUILD_SEED_IMAGE"]="true"
            ;;
        --journald-storage-persistent)
            BUILDER_CONFIG["JOURNAL_STORAGE_PERSISTENT"]="true"
            ;;
        --disable-ssh-server)
            BUILDER_CONFIG["DISABLE_SSH_SERVER"]="true"
            ;;
        --seed-root-ssh-authorized-keys)
            # multiple keys can be passed, but at least one
            while
                f=$(validate_file ${2})
                if [ -n "${f}" ] && [ -f ${f} ]; then
                    SSH_PUB_KEY_FILES="${f} ${SSH_PUB_KEY_FILES}"
                else
                    break
                fi
                shift
            do [ -z "${f}" ]; done
            # we need at least one pub key file
            if [ -z "${SSH_PUB_KEY_FILES}" ]; then
                print_debug 0 "wrong ssh public key file was passed [ ${SSH_PUB_KEY_FILES} ]"
                exit
            fi
            ;;
        --enable-early-getty)
            BUILDER_CONFIG["ENABLE_EARLY_GETTY"]="true"
            ;;
        --set-hostname)
            if [ -n "${2}" ]; then
               BUILDER_CONFIG["HOSTNAME"]="${2}"
            else
               print_debug 0 "Missing hostname parameter"
            fi
            shift
            ;;
        --backdoor)
            if [ -n "${2}" ]; then
                BUILDER_CONFIG["BACKDOOR_USER"]="${2}"
            else
                print_debug 0 "Missing backdoor user parameter"
            fi
            shift
            ;;
        --import-id)
            if [ -n "${2}" ]; then
                BUILDER_CONFIG["BACKDOOR_PARAMS"]="${BUILDER_CONFIG["BACKDOOR_PARAMS"]:+${BUILDER_CONFIG["BACKDOOR_PARAMS"]} }--import-id ${2}"
            else
                print_debug 0 "Missing import-id parameter"
            fi
            shift
            ;;
        --password)
            if [ -n "${2}" ]; then
                BUILDER_CONFIG["BACKDOOR_PARAMS"]="${BUILDER_CONFIG["BACKDOOR_PARAMS"]:+${BUILDER_CONFIG["BACKDOOR_PARAMS"]} }--password ${2}"
            else
                print_debug 0 "Missing password parameter"
            fi
            shift
            ;;
        --pubkeys)
            if [ -n "${2}" ]; then
                BUILDER_CONFIG["BACKDOOR_PARAMS"]="${BUILDER_CONFIG["BACKDOOR_PARAMS"]:+${BUILDER_CONFIG["BACKDOOR_PARAMS"]} }--pubkeys ${2}"
            else
                print_debug 0 "Missing pubkeys parameter"
            fi
            shift
            ;;
        --password-auth)
            BUILDER_CONFIG["BACKDOOR_PARAMS"]="${BUILDER_CONFIG["BACKDOOR_PARAMS"]:+${BUILDER_CONFIG["BACKDOOR_PARAMS"]} }--password-auth"
            ;;
        -d | --debug)
            BUILDER_CONFIG["BUILDER_DEBUG"]=3
            ;;
        -dd)
            BUILDER_CONFIG["BUILDER_DEBUG"]=5
            ;;
        -v | --version)
            echo -e "version: ${SCRIPT_VERSION}"
            exit 0
            ;;
        *)
            # check if this is model assertion
            ma=$(validate_file ${1})
            if [ -n "${ma}" ]; then
                BUILDER_CONFIG["MODEL_ASSERTION"]=${ma}
            else
                print_debug 0 "Unknown parameter '$1'"
                print_help
                exit
            fi
            ;;
    esac
    shift
done

# check we have all the permissions
check_snap_environment

# first create or clean work directory
prepare_work_directory

print_builder_config

# run snap prepare image with all known parameters
print_debug 1 "Running: snap prepare-image ${BUILDER_CONFIG["CHANNEL"]} ${BUILDER_CONFIG["SNAPS"]} ${BUILDER_CONFIG["MODEL_ASSERTION"]} ${BUILDER_CONFIG["WORK_DIR"]}"
if ! snap prepare-image ${BUILDER_CONFIG["CHANNEL"]} ${BUILDER_CONFIG["SNAPS"]} ${BUILDER_CONFIG["MODEL_ASSERTION"]} ${BUILDER_CONFIG["WORK_DIR"]} 2>&1 | tee -a ${BUILDER_CONFIG["TMP_LOG_FILE"]}; then
  print_debug 0 "snap prepare-image failed, bailing out"
  exit
fi
print_debug 2 "snap prepare-image completed"

BUILDER_CONFIG["GADGET_DIR"]="${BUILDER_CONFIG["WORK_DIR"]}/gadget"
BUILDER_CONFIG["GADGET_YAML"]="${BUILDER_CONFIG["GADGET_DIR"]}/meta/gadget.yaml"

# merge logs
mv ${BUILDER_CONFIG["TMP_LOG_FILE"]} ${BUILDER_CONFIG["WORK_DIR"]}/builder.log
# determine bootloader
determine_uc2x
determine_bootloader

# updated seeded image per passed configurations
# add build timestamp if provided
disk_info_contents

# for UC20 there are no additional image modifications supported yet
if [ "${BUILDER_CONFIG["UC20"]}" != "true" ]; then
    # seed cloud init user_data if provided
    seed_cloud_init_user_data
    # seed cloud init network config if provided
    seed_cloud_init_net_config
    # seed netplan network config if provided
    seed_netplan_config
    # seed auto import assertion if provided
    seed_auto_import_assertion
    # disable console conf if requested
    disable_console_conf
    # enable early getty if requested
    enable_early_getty
    # check if device should be configured with persistent journal storage
    enable_persisten_journal
    # check if system's ssh server should be disabled
    disable_ssh_server
    # check if we should set default hostname
    seed_hostname
    # check if we should seed authorized ssh kyes for root user
    seed_root_authorized_keys
    # Apply custom overlay if there are some
    seed_custom_overlay
    # Create backdoor if defined
    create_backdoor
else
    if [ -n "${BUILDER_CONFIG["CLOUD_INIT_USER_DATA"]}" ] \
       || [ -n "${BUILDER_CONFIG["CLOUD_INIT_NETWORK_CONFIG"]}" ] \
       || [ -n "${BUILDER_CONFIG["NETPLAN_CONF"]}" ] \
       || [ -n "${BUILDER_CONFIG["ASSERTION_IMPORT"]}" ] \
       || [ "true" = "${BUILDER_CONFIG["DISABLE_CONSOLE_CONF"]}" ] \
       || [ "true" = "${BUILDER_CONFIG["ENABLE_EARLY_GETTY"]}" ] \
       || [ "${BUILDER_CONFIG["JOURNAL_STORAGE_PERSISTENT"]}" = "true" ] \
       || [ "${BUILDER_CONFIG["DISABLE_SSH_SERVER"]}" = "true" ] \
       || [ -n "${BUILDER_CONFIG["HOSTNAME"]}" ] \
       || [ -n "${SSH_PUB_KEY_FILES}" ] \
       || [ -n "${BUILDER_CONFIG["CUSTOM_OVERLAY"]}" ]; then
         echo "!!! Ignoring any passed overlays, not yet supported for UC20 !!!!!"
    fi
fi

# prepare output directory
if [ -d ${BUILDER_CONFIG["OUTPUT_DIR"]} ]; then
    print_debug 2 "Cleaning output directory [${BUILDER_CONFIG["OUTPUT_DIR"]}]"
    rm -rf ${BUILDER_CONFIG["OUTPUT_DIR"]}
fi
mkdir -p ${BUILDER_CONFIG["OUTPUT_DIR"]}

# UC16/18 can have custom or normal part schema
if [ "${BUILDER_CONFIG["UC20"]}" = "true" ]; then
  # create ubuntu-seed image
  create_uc20_seed_partition_image
else
  # create system boot if needed
  create_system_boot_partition_image

  # check if gadget has partition 'seed', for factory reset
  if [ -n "$(yq eval '.volumes.[].structure.[] | select(.name == "seed") | .name' ${BUILDER_CONFIG["GADGET_YAML"]})" ]; then
    # creating seed partition image
    create_seed_partition_image
  else
    # create write partition image
    create_writable_partition_image
  fi
fi
# copy release files to output directory or run amba image build
# if we are building system-seed image, do not run amba_image_build
if [ "${BUILDER_CONFIG["AMBOOT"]}" = "true" ] && \
   [ "${BUILDER_CONFIG["BUILD_SEED_IMAGE"]}" != "true" ]; then
  run_amba_image_build
else
  copy_release_files
fi

# create image manifest
generate_manifest

print_debug 0 "\nOutput available in: '${BUILDER_CONFIG["OUTPUT_DIR"]}'"
